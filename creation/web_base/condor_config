######################################################################
##
##  condor_config
##
##  This is the global configuration file for condor.
##
######################################################################

LOG = $(LOCAL_DIR)/log
EXECUTE = $(LOCAL_DIR)/execute
COLLECTOR_HOST = $(HEAD_NODE)
FILESYSTEM_DOMAIN = $(HOSTNAME)
UID_DOMAIN = $(HOSTNAME)

SBIN = $(CONDOR_DIR)/sbin
LIBEXEC = $(CONDOR_DIR)/libexec

MAIL = /bin/mail
DAEMON_LIST = MASTER, STARTD
MASTER_ADDRESS_FILE = $(LOG)/.master_address
MASTER = $(SBIN)/condor_master
MASTER_LOG = $(LOG)/MasterLog
STARTD = $(SBIN)/condor_startd
STARTER = $(SBIN)/condor_starter

STARTER_LIST = STARTER

LOCK = $(LOG)
STARTD_LOG = $(LOG)/StartdLog
STARTER_LOG = $(LOG)/StarterLog

ALL_DEBUG = D_PID
STARTD_DEBUG = D_PID D_JOB
STARTER_DEBUG = D_PID 
MASTER_DEBUG = D_PID

# needed since Condor v6.9.2
# does not hurt for older versions
PROCD = $(SBIN)/condor_procd
PROCD_ADDRESS = $(LOCK)/procd_address
PROCD_LOG = $(LOG)/ProcLog
PROCD_DEBUG = False
PROCD_MAX_SNAPSHOT_INTERVAL = 60


SUSPEND = False
CONTINUE = True
PREEMPT = False
WANT_VACATE = False
WANT_SUSPEND = True
SUSPEND_VANILLA = False
WANT_SUSPEND_VANILLA = True

# if it ever enters the Preempting/Vacating state, get out of it in 5 minutes
# should never happen, but it is a good precaution
KILL = (CurrentTime-EnteredCurrentActivity>300)

IS_GLIDEIN = True
MASTER_ATTRS = IS_GLIDEIN, GLIDEIN_ToRetire, GLIDEIN_Expire, DaemonStopTime, $(GLIDEIN_VARIABLES)
STARTD_ATTRS = GLIDEIN_MASTER_NAME, IS_GLIDEIN, GLIDEIN_ToRetire, GLIDEIN_Expire, START, DaemonStopTime, $(GLIDEIN_VARIABLES)

# effectively disable checking of new binaries
MASTER_CHECK_NEW_EXEC_INTERVAL = 3600000

# No need to be nice... I got the slot
JOB_RENICE_INCREMENT = 0

#If the daemon crashes, run away fast
MASTER_BACKOFF_CEILING = 600

# how often should should starter update shadow with dynamic attributes?
# default = 1200 sec, choose a larger value, at the expense of less
# visibility into condor_q job dynamic attributes: cpu time, image size,
# etc
# now in condor_vars.lst
#STARTER_UPDATE_INTERVAL = 3600

# This section contains macros are here to help write legible
# expressions:

MINUTE          = 60
HOUR            = (60 * $(MINUTE))
StateTimer      = (CurrentTime - EnteredCurrentState)
ActivityTimer   = (CurrentTime - EnteredCurrentActivity)
ActivationTimer = (CurrentTime - JobStart)

BenchmarkTimer = (CurrentTime - LastBenchmark)
RunBenchmarks : (LastBenchmark == 0 ) || ($(BenchmarkTimer) >= (4 * $(HOUR)))

GSI_DAEMON_DIRECTORY=$(LOCAL_DIR)
SEC_DEFAULT_AUTHENTICATION = REQUIRED
SEC_DEFAULT_AUTHENTICATION_METHODS = GSI 

DENY_WRITE = anonymous@*
DENY_ADMINISTRATOR = anonymous@*
DENY_DAEMON = anonymous@*
DENY_NEGOTIATOR = anonymous@*

LOCAL_CONFIG_FILE       = 

NUM_CPUS = 2
VIRTUAL_MACHINE_TYPE_1 = cpus=1, memory=1%, swap=1%, disk=1%
NUM_VIRTUAL_MACHINES_TYPE_1 = 1
VIRTUAL_MACHINE_TYPE_2 = cpus=1, memory=99%, swap=99%, disk=99%
NUM_VIRTUAL_MACHINES_TYPE_2 = 1

STARTD_RESOURCE_PREFIX = vm

# Allow cross-VM expressions
STARTD_VM_EXPRS = State, EnteredCurrentState, Activity, EnteredCurrentActivity, RemoteUser, Name, GlobalJobId

#VM1_START_CONDITION = ($(WMS_TEST_START) && (WMSGroup =?= "test"))
#VM2_START_CONDITION = ($(WMS_DEFAULT_START) && (WMSGroup =!= "Held"))
#TIMEOUT_START_CONDITION = ((GLIDEIN_TORETIRE+WMSMaxTime+1200)<GLIDEIN_EXPIRE)

#START = (((VirtualMachineID == 1) && $(VM1_START_CONDITION)) ||((VirtualMachineID == 2) && $(VM2_START_CONDITION))) && $(TIMEOUT_START_CONDITION)

GLIDEIN_START_CONDITION = ($(GLIDEIN_Start)) && ($(GLIDEIN_Entry_Start))

HAS_MONITOR_VM=True
IS_MONITOR_VM = (VirtualMachineID == 1)
VM2_Monitoring_Name = VM1_Name
# use plural names, since there may be more than one if multiple job VMs
VM1_Monitored_Names = VM2_Name
VM1_Monitored_GlobalJobIds = VM2_GlobalJobId

STARTD_ATTRS = $(STARTD_ATTRS), IS_MONITOR_VM, HAS_MONITOR_VM
VM1_STARTD_ATTRS = Monitored_Names,Monitored_GlobalJobIds
VM2_STARTD_ATTRS = Monitoring_Name

VM1_VM2_MATCH = (vm2_State =?= "Claimed") && (vm2_RemoteUser =?= User)
VM1_START_CONDITION = ($(VM1_VM2_MATCH)) && ((GLIDEIN_Is_Monitor=?=True) || (JOB_Is_Monitor=?=True))
VM2_START_CONDITION = $(GLIDEIN_START_CONDITION)
START = ((VirtualMachineID == 1) && ($(VM1_START_CONDITION))) || ((VirtualMachineID == 2) && ($(VM2_START_CONDITION)))

IsOwner = (VirtualMachineID == 1) && (START =?= False)

RANK = ($(GLIDEIN_Rank)) + ($(GLIDEIN_Entry_Rank))

# Max time a job can run in the glidein
MaxJobRetirementTime=$(GLIDEIN_Job_Max_Time)
SHUTDOWN_GRACEFUL_TIMEOUT=$(GLIDEIN_Job_Max_Time)

# How long will it wait in an unclaimed state before exiting
STARTD_NOCLAIM_SHUTDOWN = $(GLIDEIN_Max_Idle)

# randomize update interval to minimize packet loss
UPDATE_INTERVAL = $RANDOM_INTEGER(270, 370, 1)
MASTER_UPDATE_INTERVAL = $RANDOM_INTEGER(270, 330, 1)


