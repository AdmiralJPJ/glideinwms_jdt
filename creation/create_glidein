#!/bin/env python

import popen2
import os
import copy
import sys
import os.path
import string
import shutil
import traceback
sys.path.append("lib")
import cgWParams
import cgWConsts
import cgWCreate


################################################################################

def main(params):
    #print params.__dict__
    create_dir(params.submit_dir)
    try:
        # create log submit subdir
        create_dir(os.path.join(params.submit_dir,"log")) # no try/except needed, will be deleted by external except if needed

        # create entry dirs, including internal log dirs
        for entry_name in params.entries.keys():
            entry_dir=os.path.join(params.submit_dir,"entry_"+entry_name)
            create_dir(entry_dir)
            create_dir(os.path.join(entry_dir,"log"))
        
        create_dir(params.stage_dir)
        try:
            # create entry dirs
            for entry_name in params.entries.keys():
                entry_dir=os.path.join(params.stage_dir,"entry_"+entry_name)
                create_dir(entry_dir) # no try/except needed, will be deleted by external except if needed

            create_dir(params.monitor_dir)
            try:
               # create entry dirs
               for entry_name in params.entries.keys():
                   entry_dir=os.path.join(params.monitor_dir,"entry_"+entry_name)
                   create_dir(entry_dir) # no try/except needed, will be deleted by external except if needed
                    
               # make a link from the submit dir to the monitor dir
               symlink_file(params.monitor_dir,os.path.join(params.submit_dir)+"/monitor")

               # create dictionary variables
               main_dicts={'summary_signature':SummarySHA1DictFile(params.submit_dir,cgWConsts.SUMMARY_SIGNATURE_FILE),
                           'attrs':DictFile(params.stage_dir,cgWConsts.ATTRS_FILE),
                           'description':DescriptionDictFile(params.stage_dir,cgWConsts.DESCRIPTION_FILE),
                           'consts':DictFile(params.stage_dir,cgWConsts.CONSTS_FILE),
                           'params':DictFile(params.submit_dir,cgWConsts.PARAMS_FILE),
                           'vars':VarsDictFile(params.stage_dir,cgWConsts.VARS_FILE),
                           'file_list':FileDictFile(params.stage_dir,cgWConsts.FILE_LISTFILE),
                           'script_list':FileDictFile(params.stage_dir,cgWConsts.SCRIPT_LISTFILE),
                           'subsystem_list':SubsystemDictFile(params.stage_dir,cgWConsts.SUBSYSTEM_LISTFILE),
                           "signature":SHA1DictFile(params.stage_dir,cgWConsts.SIGNATURE_FILE)}
               entry_dicts={}
               for entry_name in params.entries.keys():
                   entry_submit_dir=os.path.join(params.submit_dir,"entry_"+entry_name)
                   entry_stage_dir=os.path.join(params.stage_dir,"entry_"+entry_name)
                   entry_dicts[entry_name]={'attrs':DictFile(entry_stage_dir,cgWConsts.ATTRS_FILE),
                                            'description':DescriptionDictFile(entry_stage_dir,cgWConsts.DESCRIPTION_FILE),
                                            'consts':DictFile(entry_stage_dir,cgWConsts.CONSTS_FILE),
                                            'params':DictFile(entry_submit_dir,cgWConsts.PARAMS_FILE),
                                            'vars':VarsDictFile(entry_stage_dir,cgWConsts.VARS_FILE),
                                            'file_list':FileDictFile(entry_stage_dir,cgWConsts.FILE_LISTFILE),
                                            'script_list':FileDictFile(entry_stage_dir,cgWConsts.SCRIPT_LISTFILE),
                                            'subsystem_list':SubsystemDictFile(entry_stage_dir,cgWConsts.SUBSYSTEM_LISTFILE),
                                            "signature":SHA1DictFile(entry_stage_dir,cgWConsts.SIGNATURE_FILE)}

               # create basic description file(s)
               create_description_file(main_dicts)
               for entry_name in params.entries.keys():
                   create_description_file(entry_dicts[entry_name])

               # put user files in stage
               for file in params.files:
                   copy_file_unparsed(file,params.stage_dir,main_dicts)
               ## repeat for all the entries
               for entry_name in params.entries.keys():
                   entry_stage_dir=os.path.join(params.stage_dir,"entry_"+entry_name)
                   for file in params.entries[entry_name].files:
                       copy_file_unparsed(file,entry_stage_dir,entry_dicts[entry_name])

               #put condor tarball into stage
               if params.condor.tar_file!=None: # condor tarball available
                   condor_uf=cgWParams.SubParams({"absfname":params.condor.tar_file,
                                                  "relfname":cgWConsts.CONDOR_FILE,
                                                  "const":"True",
                                                  "untar":"True",
                                                  "untar_options":{"cond_attr":None,
                                                                   "dir":cgWConsts.CONDOR_DIR,
                                                                   "absdir_outattr":cgWConsts.CONDOR_ATTR}})
                   copy_file_unparsed(condor_uf,params.stage_dir,main_dicts)
               else: # create a new tarball
                   create_condor_tar(params.stage_dir,main_dicts,params.condor.base_dir)
               
               #put system files into stage
               copy_stage_file("parse_starterlog.awk",params.stage_dir,params.src_dir,main_dicts)
               copy_stage_file("condor_config",params.stage_dir,params.src_dir,main_dicts)
               main_dicts['vars'].load(params.src_dir,'condor_vars.lst') # will be modified when attrs processed
               copy_script("setup_x509.sh",params.stage_dir,params.src_dir,main_dicts)
               copy_script("validate_node.sh",params.stage_dir,params.src_dir,main_dicts)
               
                ## repeat for all the entries
               for entry_name in params.entries.keys():
                   entry_stage_dir=os.path.join(params.stage_dir,"entry_"+entry_name)
                   entry_dicts[entry_name]['vars'].load(params.src_dir,'condor_vars.lst.entry') # will be modified when attrs processed
                   copy_stage_file("nodes.blacklist",entry_stage_dir,params.src_dir,entry_dicts[entry_name],can_be_modified=1)
              
               # put user attributes into config files
               for attr_name in params.attrs.keys():
                   add_attr_unparsed(attr_name, params.attrs[attr_name],main_dicts,"main")

               # add the basic standard params
               add_param(main_dicts,"GLIDEIN_Collector",'Fake',is_string=True)

               # this must be the last script in the list
               copy_script(cgWConsts.CONDOR_STARTUP_FILE,params.stage_dir,params.src_dir,main_dicts)
               main_dicts['description'].add(cgWConsts.CONDOR_STARTUP_FILE,"last_script")

               # finalize
               save_dict_files(main_dicts,"main")

               ## repeat for all the entries
               for entry_name in params.entries.keys():
                   for attr_name in params.entries[entry_name].attrs.keys():
                       add_attr_unparsed(attr_name, params.entries[entry_name].attrs[attr_name],entry_dicts[entry_name],"entry_"+entry_name)
                   save_dict_files(entry_dicts[entry_name],"entry_"+entry_name)

               # calculate signatures
               finalize_sha1(main_dicts,entry_dicts)

               #
               # Stage is finished
               # Populate submit dir
               #

               # copy the startup file
               copy_submit_file(cgWConsts.STARTUP_FILE,params.submit_dir,params.src_dir)

               link_attributes(params.submit_dir,params.stage_dir,bool(params.stage.use_symlink))
               for entry_name in params.entries.keys():
                   entry_stage_dir=os.path.join(params.stage_dir,"entry_"+entry_name)
                   entry_submit_dir=os.path.join(params.submit_dir,"entry_"+entry_name)
                   link_attributes(entry_submit_dir,entry_stage_dir,bool(params.stage.use_symlink))

               cgWCreate.create_glidein_descript(params.submit_dir,
                                                 params.factory_name,params.glidein_name,
                                                 params.web_url,
                                                 params.entries.keys())

               cgWCreate.create_submit(params.submit_dir,
                                       params.factory_name,params.glidein_name,
                                       params.web_url)

               cgWCreate.create_submit_wrapper(params.submit_dir)
               cgWCreate.create_test_submit(params.submit_dir)

               params.save_into_file(os.path.join(params.submit_dir,cgWConsts.XML_CONFIG_FILE))

               global_schedd_names=string.split(params.schedd_name,',')
               global_schedd_idx=0
               for entry_name in params.entries.keys():
                   entry_stage_dir=os.path.join(params.stage_dir,"entry_"+entry_name)
                   entry_submit_dir=os.path.join(params.submit_dir,"entry_"+entry_name)
                   entry_el=params.entries[entry_name]

                   schedd_name=entry_el.schedd_name
                   if schedd_name==None:
                       # use one of the global ones if specific not provided
                       schedd_name=global_schedd_names[global_schedd_idx%len(global_schedd_names)]
                       global_schedd_idx=global_schedd_idx+1
                   
                   cgWCreate.create_job_descript(entry_submit_dir,entry_name,
                                                 entry_el.gridtype,entry_el.gatekeeper,entry_el.rsl,
                                                 schedd_name,
                                                 entry_el.work_dir,entry_el.proxy_url)

            except:
               shutil.rmtree(params.monitor_dir)
               raise
        except:
            shutil.rmtree(params.stage_dir)
            raise
    except:
        shutil.rmtree(params.submit_dir)
        raise

    print "Created glidein '%s'"%params.glidein_name
    print "Submit files can be found in %s"%params.submit_dir
    print "Support files are in %s"%params.stage_dir
    print "Monitoring files are in %s"%params.monitor_dir


############################################################
#
# P R I V A T E - Do not use
# 
############################################################

class DictFile:
    def __init__(self,dir,fname,sort_keys=0):
        self.dir=dir
        self.fname=fname
        self.sort_keys=sort_keys

        self.is_readonly=False
        
        self.keys=[]
        self.vals={}

    def has_key(self,key):
        return key in self.keys

    def __getitem__(self,key):
        return self.vals[key]

    def get_fname(self):
        return self.fname

    def get_dir(self):
        return self.dir

    def erase(self):
        self.keys=[]
        self.vals={}
        
    def set_readonly(self,readonly=True):
        self.is_readonly=readonly


    def add(self,key,val,allow_overwrite=False):
        if self.is_readonly:
            raise RuntimeError, "Trying to modify a readonly object!"
        
        if key in self.keys:
            if not allow_overwrite:
                raise RuntimeError, "Key '%s' already exists"%key
            elif not self.is_compatible(self.vals[key],val):
                raise RuntimeError, "Key '%s': Value %s not compatible with old value %s"%(key,val,self.vals[key])
        else:
            self.keys.append(key)
        self.vals[key]=val

    def save(self, dir=None, fname=None,sort_keys=None): # if dir and/or fname are not specified, use the defaults specified in __init__
        if dir==None:
            dir=self.dir
        if fname==None:
            fname=self.fname
        if sort_keys==None:
            sort_keys=self.sort_keys


        filepath=os.path.join(dir,fname)
        try:
            fd=open(filepath,"w")
        except IOError,e:
            raise RuntimeError, "Error creating %s: %s"%(filepath,e)
        try:
            header=self.file_header()
            if header!=None:
                fd.write("%s\n"%header)
            if sort_keys:
                keys=self.keys[0:]
                keys.sort()
            else:
                keys=self.keys
            for k in keys:
                fd.write("%s\n"%self.format_val(k))
        finally:
            fd.close()
        return

    def load(self, dir=None, fname=None): # if dir and/or fname are not specified, use the defaults specified in __init__
        if dir==None:
            dir=self.dir
        if fname==None:
            fname=self.fname

        filepath=os.path.join(dir,fname)
        try:
            fd=open(filepath,"r")
        except IOError,e:
            raise RuntimeError, "Error opening %s: %s"%(filepath,e)
        try:
            lines=fd.readlines()
        finally:
            fd.close()

        idx=0
        for line in lines:
            idx+=1
            if line[-1]=='\n':
                # strip newline
                line=line[:-1]
            try:
                self.parse_val(line)
            except RuntimeError, e:
                raise RuntimeError, "File %s, line %i:%s"%(filepath,idx,str(e))
        return

    # PRIVATE
    def is_compatible(self,old_val,new_val):
        return True # everything is compatible
    
    def file_header(self):
        return None # no header
    
    def format_val(self,key):
        return "%s \t%s"%(key,self.vals[key])

    def parse_val(self,line):
        if line[0]=='#':
            return # ignore comments
        arr=line.split(None,1)
        if len(arr)==0:
            return # empty line
        if len(arr[0])==0:
            return # empty key

        key=arr[0]
        if len(arr)==1:
            val=''
        else:
            val=arr[1]
        return self.add(key,val)

# signatures
class DescriptionDictFile(DictFile):
    def format_val(self,key):
        return "%s \t%s"%(self.vals[key],key)

    def parse_val(self,line):
        if line[0]=='#':
            return # ignore comments
        arr=line.split(None,1)
        if len(arr)==0:
            return # empty line
        if len(arr)!=2:
            raise RuntimeError,"Not a valid description line: '%s'"%line

        return self.add(arr[1],arr[0])
    
# signatures
class SHA1DictFile(DictFile):
    def format_val(self,key):
        return "%s  %s"%(self.vals[key],key)

    def parse_val(self,line):
        if line[0]=='#':
            return # ignore comments
        arr=line.split(None,1)
        if len(arr)==0:
            return # empty line
        if len(arr)!=2:
            raise RuntimeError,"Not a valid SHA1 line: '%s'"%line

        return self.add(arr[1],arr[0])
    
# summary signatures
# values are (sha1,fname)
class SummarySHA1DictFile(DictFile):
    def add(self,key,val,allow_overwrite=False):
        if not (type(val) in (type(()),type([]))):
            raise RuntimeError, "Values '%s' not a list or tuple"%val
        if len(val)!=2:
            raise RuntimeError, "Values '%s' not (sha1,fname)"%val
        return DictFile.add(self,key,val,allow_overwrite)

    def format_val(self,key):
        return "%s  %s  %s"%(self.vals[key][0],self.vals[key][1],key)

    def parse_val(self,line):
        if line[0]=='#':
            return # ignore comments
        arr=line.split(None,2)
        if len(arr)==0:
            return # empty line
        if len(arr)!=3:
            raise RuntimeError,"Not a valid summary signature line (expected 4, found %i elements): '%s'"%(len(arr),line)

        key=arr[2]
        return self.add(key,(arr[0],arr[1]))

# file_list
class FileDictFile(DictFile):
    def format_val(self,key):
        if self.vals[key]!=None:
            return "%s %s"%(key,self.vals[key])
        else:
            return key

    def parse_val(self,line):
        if line[0]=='#':
            return # ignore comments
        arr=line.split(None,1)
        if len(arr)==0:
            return # empty line
        if len(arr[0])==0:
            return # empty key

        key=arr[0]
        if len(arr)==1:
            val=None
        else:
            val=arr[1]
        return self.add(key,val)

# subsystem
# values are (config_check,wnsubdir,config_out)
class SubsystemDictFile(DictFile):
    def add(self,key,val,allow_overwrite=False):
        if not (type(val) in (type(()),type([]))):
            raise RuntimeError, "Values '%s' not a list or tuple"%val
        if len(val)!=3:
            raise RuntimeError, "Values '%s' not (config_check,wnsubdir,config_out)"%val
        return DictFile.add(self,key,val,allow_overwrite)

    def format_val(self,key):
        return "%s %s %s %s"%(self.vals[key][0],self.vals[key][1],key,self.vals[key][2])# condor_vars

    def parse_val(self,line):
        if line[0]=='#':
            return # ignore comments
        arr=line.split(None,3)
        if len(arr)==0:
            return # empty line
        if len(arr)!=4:
            raise RuntimeError,"Not a valid subsystem line (expected 4, found %i elements): '%s'"%(len(arr),line)

        key=arr[2]
        return self.add(key,(arr[0],arr[1],arr[3]))

# values are (Type,Default,CondorName,Required,Export,UserName)
class VarsDictFile(DictFile):
    def is_compatible(self,old_val,new_val):
        return ((old_val[0]==new_val[0]) and (old_val[4]==new_val[4]))# at least the type and the export must be preserved
    
    def file_header(self):
        return ("# VarName               Type    Default         CondorName                     Req.     Export  UserName           \n"+
                "#                       S=Quote - = No Default  + = VarName                             Condor   - = Do not export \n"+
                "#                                                                                                + = Use VarName   \n"+
                "#                                                                                                @ = Use CondorName\n"
                "###################################################################################################################")

    def add(self,key,val,allow_overwrite=0):
        if not (type(val) in (type(()),type([]))):
            raise RuntimeError, "Values '%s' not a list or tuple"%val
        if len(val)!=6:
            raise RuntimeError, "Values '%s' not (Type,Default,CondorName,Required,Export,UserName)"%val
        if not (val[0] in ('C','S','I')):
            raise RuntimeError,"Invalid var type '%s', should be either C, S or I in val: %s"%(val[1],val)
        for i,t in ((3,"Required"),(4,"Export")):
            if not (val[i] in ('Y','N')):
                raise RuntimeError,"Invalid var %s '%s', should be either Y or N in val: %s"%(t,val[i],val)

        return DictFile.add(self,key,val,allow_overwrite)

    def format_val(self,key):
        return "%s \t%s \t%s \t\t%s \t%s \t%s \t%s"%(key,self.vals[key][0],self.vals[key][1],self.vals[key][2],self.vals[key][3],self.vals[key][4],self.vals[key][5])
        

    def parse_val(self,line):
        if len(line)==0:
            return #ignore emoty lines
        if line[0]=='#':
            return # ignore comments
        arr=line.split(None,6)
        if len(arr)==0:
            return # empty line
        if len(arr)!=7:
            raise RuntimeError,"Not a valid var line (expected 7, found %i elements): '%s'"%(len(arr),line)

        key=arr[0]
        return self.add(key,arr[1:])

#####################
# Simply create a dir
def create_dir(dirname):
    try:
        os.mkdir(dirname)
    except OSError, e:
        raise RuntimeError, "Cannot create dir %s: %s"%(dirname,e)

#####################
# Simply copy a file
def copy_file(infile,outfile):
    try:
        shutil.copy2(infile,outfile)
    except IOError, e:
        raise RuntimeError, "Error copying %s in %s: %s"%(infile,outfile,e)
        
#######################
# Simply symlink a file
def symlink_file(infile,outfile):
    try:
        os.symlink(infile,outfile)
    except IOError, e:
        raise RuntimeError, "Error symlink %s in %s: %s"%(infile,outfile,e)
        

########################
# Write a line in a file
def add_line(filename,dir,line):
    filepath=os.path.join(dir,filename)
    try:
        fd=open(filepath,"a+")
    except IOError,e:
        raise RuntimeError, "Error appending to %s: %s"%(filepath,e)
    try:
        fd.write("%s\n"%line)
    finally:
        fd.close()

############################
# Add a published attributed
def add_attr(dicts,attr_name,attr_val,is_string):
    if is_string:
        attr_val=repr(attr_val)
    else:
        attr_val=repr(int(attr_val))

    dicts['attrs'].add(attr_name,attr_val)


############################
# Add a constant attribute
def add_const(dicts,attr_name,attr_val):
    dicts['consts'].add(attr_name,attr_val)

########################
# Add a parameter
def add_param(dicts,param_name,param_defval,is_string):
    if is_string:
        param_defval=repr(param_defval)
    else:
        param_defval=repr(int(param_defval))

    dicts['params'].add(param_name,param_defval)

#################################
# Calculate SHA1 for the file
def calc_sha1(filename,stage_dir):
    filepath=os.path.join(stage_dir,filename)
    try:
        sha1=string.split(exe_cmd("sha1sum %s"%filepath)[0])[0]
    except RuntimeError, e:
        raise RuntimeError, "Error calculating SHA1 for %s: %s"%(filepath,e)
    return sha1

#################################
# Calculate SHA1 for the file and
# put it into the signature file
def add_sha1(filename,stage_dir,dicts):
    sha1=calc_sha1(filename,stage_dir)
    dicts['signature'].add(filename,sha1)

#################################
# Add a new variable to VARS_FILE
def add_var(dicts,attr_name,is_string,do_glidein_publish,do_job_publish):
    type_str={True:"S",False:"I"}
    glide_str={True:"Y",False:"N"}
    job_str={True:"+",False:"-"}
    dicts['vars'].add(attr_name,(type_str[is_string],'-','+','N',glide_str[do_glidein_publish],job_str[do_job_publish]))
    
#########################
# Register a regular file
def add_file(filename,stage_dir,dicts,can_be_modified=0,description=None):
    if can_be_modified:
        dicts['file_list'].add(filename,'nocache')
    else:
        add_sha1(filename,stage_dir,dicts)
        dicts['file_list'].add(filename,None)
    if description!=None:
        dicts['description'].add(filename,description)


###################
# Register a script
def add_script(filename,stage_dir,dicts):
    add_sha1(filename,stage_dir,dicts)
    dicts['script_list'].add(filename,None)

######################
# Register a subsystem
def add_subsystem(filename,stage_dir,dicts,config_check,wnsubdir,config_out):
    if config_check==None:
        config_check="TRUE" #TRUE has a special meaning for the glidein
    add_sha1(filename,stage_dir,dicts)
    dicts['subsystem_list'].add(filename,(config_check,wnsubdir,config_out))
    if config_check!="TRUE":
        # TRUE is not a real parameter, so no need to log it
        add_param(dicts,config_check,0,is_string=False) # if it is optional, default==0

##########################################
# Creates the summary_signature file
def finalize_sha1(dicts,entry_dicts):
    sha1=calc_sha1(dicts['signature'].get_fname(),dicts['signature'].get_dir())
    dicts['summary_signature'].add('main',(sha1,dicts['description'].get_fname()))
    for entry_name in entry_dicts.keys():
        e_dicts=entry_dicts[entry_name]
        sha1=calc_sha1(e_dicts['signature'].get_fname(),e_dicts['signature'].get_dir())
        dicts['summary_signature'].add("entry_"+entry_name,(sha1,e_dicts['description'].get_fname()))

    dicts['summary_signature'].save()
    dicts['summary_signature'].set_readonly()
    return
    
##########################################
# Create description file
def create_description_file(dicts):
    description_dict=dicts['description']
    description_dict.add(cgWConsts.SIGNATURE_FILE,"signature")
    description_dict.add(cgWConsts.FILE_LISTFILE,"file_list")
    description_dict.add(cgWConsts.SCRIPT_LISTFILE,"script_list")
    description_dict.add(cgWConsts.SUBSYSTEM_LISTFILE,"subsystem_list")
    
    
#####################
# Copy a regular file
def copy_stage_file(filename,stage_dir,org_dir,dicts,can_be_modified=0,out_fname=None,description=None):
    if out_fname==None:
        copy_file(os.path.join(org_dir,filename),stage_dir)
        add_file(filename,stage_dir,dicts,can_be_modified,description)
    else:
        copy_file(os.path.join(org_dir,filename),os.path.join(stage_dir,out_fname))
        add_file(out_fname,stage_dir,dicts,can_be_modified,description)

###############
# Copy a script
def copy_script(filename,stage_dir,org_dir,dicts):
    copy_file(os.path.join(org_dir,filename),stage_dir)
    add_script(filename,stage_dir,dicts)

######################
# Copy a subsystem
def copy_subsystem(filename,stage_dir,submit_dir,org_dir,config_check,wnsubdir,config_out):
    copy_file(os.path.join(org_dir,filename),stage_dir)
    add_subsystem(filename,stage_dir,submit_dir,config_check,wnsubdir,config_out)

##########################################
# Copy a user file and add it to the list
# file as described by Params.file_defaults
def copy_file_unparsed(file,stage_dir,dicts):
    if file.absfname==None:
        raise RuntimeError, "Found a file element without an absname: %s"%file
    
    relfname=file.relfname
    if relfname==None:
        relfname=os.path.basename(file.absfname) # defualt is the final part of absfname
    if len(relfname)<1:
        raise RuntimeError, "Found a file element with an empty relfname: %s"%file

    copy_file(file.absfname,os.path.join(stage_dir,relfname))

    return add_file_unparsed(file,stage_dir,dicts)
    
#############################################
# Add a user file residing in the stage area
# file as described by Params.file_defaults
def add_file_unparsed(file,stage_dir,dicts):
    relfname=file.relfname
    if relfname==None:
        if file.absfname==None:
            raise RuntimeError, "Found a file element without either a relname or an absname: %s"%file
        relfname=os.path.basename(file.absfname) # defualt is the final part of absfname
    if len(relfname)<1:
        raise RuntimeError, "Found a file element with an empty relfname: %s"%file

    is_const=eval(file.const,{},{})
    is_executable=eval(file.executable,{},{})
    do_untar=eval(file.untar,{},{})

    if is_executable: # a script
        if not is_const:
            raise RuntimeError, "A file cannot be executable if it is not constant: %s"%file
    
        if do_untar:
            raise RuntimeError, "A tar file cannot be executable: %s"%file

        add_script(relfname,stage_dir,dicts)
    elif do_untar: # a tarball
        if not is_const:
            raise RuntimeError, "A file cannot be untarred if it is not constant: %s"%file

        wnsubdir=file.untar_options.dir
        if wnsubdir==None:
            wnsubdir=string.split(relfname,'.',1)[0] # deafult is relfname up to the first .

        #temporary, should be fixed in future versions
        if file.untar_options.absdir_outattr==None:
            raise RuntimeError, 'Currently untar_options.absdir_outattr must be defined: %s'%file
        
        add_subsystem(relfname,stage_dir,dicts,file.untar_options.cond_attr,wnsubdir,file.untar_options.absdir_outattr)
    else: # not executable nor tarball => simple file
        add_file(relfname,stage_dir,dicts,not is_const,None)


#######################
# Register an attribute
# attr_obj as described by Params.attr_defaults
def add_attr_unparsed(attr_name,attr_obj,dicts,description):
    try:
        add_attr_unparsed_real(attr_name,attr_obj,dicts)
    except RuntimeError,e:
        raise RuntimeError, "Error parsing attr %s[%s]: %s"%(description,attr_name,str(e))

def add_attr_unparsed_real(attr_name,attr_obj,dicts):
    if attr_obj.value==None:
        raise RuntimeError, "Attribute '%s' does not have a value: %s"%(attr_name,attr_obj)
    
    do_publish=eval(attr_obj.publish,{},{})
    is_parameter=eval(attr_obj.parameter,{},{})
    is_const=eval(attr_obj.const,{},{})

    if (not attr_obj.type in ("string","int")):
        raise RuntimeError, "Wrong type '%s' for attribute '%s', must be either 'int' or 'string'"%(attr_obj.type,attr_name)
    
    if do_publish: # publish in factory ClassAd
        if is_parameter: # but also push to glidein
            if is_const:
                add_attr(dicts,attr_name,attr_obj.value,attr_obj.type=="string")
                add_const(dicts,attr_name,attr_obj.value)
            else:
                add_param(dicts,attr_name,attr_obj.value,attr_obj.type=="string")
        else: # only publish
            if (not is_const):
                raise RuntimeError, "Published attribute '%s' must be either a parameter or constant: %s"%(attr_name,attr_obj)
            
            add_attr(dicts,attr_name,attr_obj.value,attr_obj.type=="string")
    else: # do not publish, only to glidein
        if is_parameter:
            if is_const:
                add_const(dicts,attr_name,attr_obj.value)
            else:
                raise RuntimeError, "Parameter attributes '%s' must be either a published or constant: %s"%(attr_name,attr_obj)
        else:
            raise RuntimeError, "Attributes '%s' must be either a published or parameters: %s"%(attr_name,attr_obj) 

    if is_parameter:
        do_glidein_publish=eval(attr_obj.glidein_publish,{},{})
        do_job_publish=eval(attr_obj.job_publish,{},{})

        if do_glidein_publish or do_job_publish:
            # need to add a line only if will be published
            if dicts['vars'].has_key(attr_name):
                # already in the var file, check if compatible
                attr_var_el=dicts['vars'][attr_name]
                attr_var_type=attr_var_el[0]
                if (((attr_obj.type=="int") and (attr_var_type!='I')) or
                    ((attr_obj.type=="string") and (attr_var_type=='I'))):
                    raise RuntimeError, "Types not compatible (%s,%s)"%(attr_obj.type,attr_var_type)
                attr_var_export=attr_var_el[4]
                if do_glidein_publish and (attr_var_export=='N'):
                    raise RuntimeError, "Cannot force glidein publishing"
                attr_var_job_publish=attr_var_el[5]
                if do_job_publish and (attr_var_job_publish=='-'):
                    raise RuntimeError, "Cannot force job publishing"
            else:
                add_var(dicts,attr_name,attr_obj.type=="string",do_glidein_publish,do_job_publish)

#############################################
# Save most of the files, but the signatures
def save_dict_files(dicts,description):
    # save files that need description
    for k,description in (('attrs','attrs_file'),('consts','consts_file'),('vars','condor_vars')):
        # save file
        dicts[k].save()
        dicts[k].set_readonly(1) # prevent changes after it was saved
        # register it
        add_file(dicts[k].get_fname(),dicts[k].get_dir(),dicts,0,description)
    # save other non-changable files
    for k in ('description','file_list','script_list','subsystem_list'):
        dicts[k].save()
        dicts[k].set_readonly(1) # prevent changes after it was saved
        add_sha1(dicts[k].get_fname(),dicts[k].get_dir(),dicts)
    # finally save the signature and submit-dir files
    for k in ('signature','params'):
        dicts[k].save()
        dicts[k].set_readonly(1) # prevent changes after it was saved
     
##############################
# Execute a command in a shell
def exe_cmd(cmd):
    childout, childin, childerr = popen2.popen3(cmd)
    childin.close()
    tempOut = childout.readlines()
    childout.close()
    tempErr = childerr.readlines()
    childerr.close()
    if (len(tempErr)!=0):
        raise RuntimeError, "Error running '%s'\n%s"%(cmd,tempErr)
    return tempOut


##############################
# Create condor tarball and
# add it to the list of subsaystems
def create_condor_tar(stage_dir,dicts,condor_base_dir):
    cgWCreate.create_condor_tar(stage_dir,condor_base_dir)
    add_subsystem(cgWConsts.CONDOR_FILE,stage_dir,dicts,None,cgWConsts.CONDOR_DIR,cgWConsts.CONDOR_ATTR)


###################################
# Create a copy or a link in the
# submit dir
def link_attributes(submit_dir,stage_dir,do_softlink):
    submit_filepath=os.path.join(submit_dir,cgWConsts.ATTRS_FILE)
    stage_filepath=os.path.join(stage_dir,cgWConsts.ATTRS_FILE)

    if do_softlink:
        symlink_file(stage_filepath,submit_filepath)
    else:
        copy_file(stage_filepath,submit_filepath)
        # Make it read only
        os.chmod(filepath,0444)

#####################
# Copy a regular file
def copy_submit_file(filename,submit_dir,org_dir):
    copy_file(os.path.join(org_dir,filename),submit_dir)

    
############################################################
#
# S T A R T U P
# 
############################################################

if __name__ == '__main__':
    try:
        params=cgWParams.Params(sys.argv)
    except RuntimeError,e:
        print e
        sys.exit(1)
    try:
        main(params)
    except RuntimeError, e:
        print params.usage()
        print ""
        print e

###########################################################
#
# CVS info
#
# $Id: create_glidein,v 1.92 2007/10/18 19:06:26 sfiligoi Exp $
#
# Log:
#  $Log: create_glidein,v $
#  Revision 1.92  2007/10/18 19:06:26  sfiligoi
#  Mayor restructuring to get all the file creation more structured
#
#  Revision 1.91  2007/10/16 15:50:59  sfiligoi
#  Split file addition from file copying
#
#  Revision 1.90  2007/10/12 21:56:24  sfiligoi
#  Add glideinWMS.cfg in the list of constants
#
#  Revision 1.89  2007/10/12 21:41:45  sfiligoi
#  Proper error message handling
#
#  Revision 1.87  2007/10/12 21:22:56  sfiligoi
#  Remove the use of sys.exit
#
#  Revision 1.85  2007/10/12 21:01:17  sfiligoi
#  Moved consts and creation funcs into dedicated modules
#
#  Revision 1.84  2007/10/12 19:27:04  sfiligoi
#  Moved cgWParams to lib subdir
#
#  Revision 1.83  2007/10/12 19:18:48  sfiligoi
#  Move find_condor_base_dir to the right place
#
#  Revision 1.82  2007/10/12 19:11:12  sfiligoi
#  Put config file parsing in a separate module
#
#  Revision 1.81  2007/07/18 22:38:30  sfiligoi
#  Add printout from parsing Condor StarterLog
#
#  Revision 1.80  2007/07/11 23:46:32  sfiligoi
#  Put description_file name into signatures.cfg
#
#  Revision 1.79  2007/07/11 22:55:19  sfiligoi
#  Rename DESCRIPT_FILE into JOB_DESCRIPT_FILE to prevent confision with the new DESCRIPTION_FILE
#
#  Revision 1.78  2007/07/11 21:57:31  sfiligoi
#  Add inital support for several versions of files in the stage area
#
#  Revision 1.77  2007/05/18 20:35:05  sfiligoi
#  Fix submit file to handle multiple schedds
#
#  Revision 1.76  2007/05/18 19:57:32  sfiligoi
#  Add support for listds of schedds
#
#  Revision 1.75  2007/05/18 19:36:21  sfiligoi
#  Add support for entry-specific schedd_names
#
#  Revision 1.74  2007/05/18 19:07:18  sfiligoi
#  Add CVS tags
#
#
###########################################################
