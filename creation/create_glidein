#!/bin/env python

import popen2
import os
import copy
import sys
import os.path
import time
import string
import shutil
import socket
import traceback
sys.path.append("../lib")
import xmlParse
import xml.parsers.expat

class SubParams:
    def __init__(self,data):
        self.data=data

    # make data elements look like class attributes
    def __getattr__(self,name):
        return self.get_el(name)

    # make data elements look like a dictionary
    def keys(self):
        return self.data.keys()
    def has_key(self,name):
        return self.data.has_key(name)
    def __getitem__(self,name):
        return self.get_el(name)    
    def __repr__(self):
        return str(self.data)
    def __str__(self):
        return str(self.data)

    #
    # PROTECTED
    #

    # validate input against bae template (i.e. the defaults)
    def validate(self,base,path_text):
        for k in self.data.keys():
            if not base.has_key(k):
                # element not in base, report
                raise RuntimeError, "Unknown parameter %s.%s"%(path_text,k)
            else:
                # verify subelements, if any
                defel=base[k]
                if type(defel)==type({}):
                    # subdictionary
                    self[k].validate(defel,"%s.%s"%(path_text,k))
                else:
                    # final element
                    defvalue,ktype,txt,subdef=defel

                    if type(defvalue)==type({}):
                        # dictionary el elements
                        data_el=self[k]
                        for data_subkey in data_el.keys():
                            data_el[data_subkey].validate(subdef,"%s.%s.%s"%(path_text,k,data_subkey))
                    elif type(defvalue)==type([]):
                        # list of elements
                        for data_el in self[k]:
                            data_el.validate(subdef,"%s.*.%s"%(path_text,k))
                    else:
                        # a simple value
                        pass #nothing to be done

    # put default values where there is nothing
    def use_defaults(self,defaults):
        for k in defaults.keys():
            defel=defaults[k]
            if type(defel)==type({}):
                # subdictionary
                if not self.data.has_key(k):
                    self.data[k]={} # first create empty, if does not exist

                # then, set defaults on all elements of subdictionary
                self[k].use_defaults(defel)
            else:
                # final element
                defvalue,ktype,txt,subdef=defel

                if type(defvalue)==type({}):
                    # dictionary el elements
                    if not self.data.has_key(k):
                        self.data[k]={} # no elements yet, set and empty dictionary
                    else:
                        # need to set defaults on all elements in the dictionary
                        data_el=self[k]
                        for data_subkey in data_el.keys():
                            data_el[data_subkey].use_defaults(subdef)
                elif type(defvalue)==type([]):
                    # list of elements
                    if not self.data.has_key(k):
                        self.data[k]=[] # no elements yet, set and empty list
                    else:
                        # need to set defaults on all elements in the list
                        for data_el in self[k]:
                            data_el.use_defaults(subdef)
                else:
                    # a simple value
                    if not self.data.has_key(k):
                        self.data[k]=copy.deepcopy(defvalue)
                    # else nothing to do, already set

            

    #
    # PRIVATE
    #
    def get_el(self,name):
        el=self.data[name]
        if type(el)==type({}):
            return SubParams(el)
        elif type(el)==type([]):
            outlst=[]
            for k in el:
                if type(k)==type({}):
                    outlst.append(SubParams(k))
                else:
                    outlst.append(k)
            return outlst
        else:
            return el
        

class Params:
    def __init__(self,argv):
        self.attr_defaults={"value":(None,"Value","Value of the attribute (string)",None),
                            "publish":("True","Bool","Should it be published by the factory?",None),
                            "parameter":("True","Bool","Should it be a parameter for the glidein?",None),
                            "const":("True","Bool","Should it be constant? (Else it can be overriden by the frontend. Used only if parameter is True.)",None),
                            "type":("string","string|int","What kind on data is value.",None)}

        self.file_defaults={"absfname":(None,"fname","File name on the local disk.",None),
                            "relfname":(None,"fname","Name of the file once it gets to the worker node. (defaults to the last part of absfname)",None),
                            "const":("True","Bool","Will the file be constant? If True, the file will be signed. If False, it can be modified at any time and will not be cached.",None),
                            "executable":("False",'Bool','Is this an executable that needs to be run in the glidein?',None),
                            "untar":("False",'Bool','Do I need to untar it? ',None),
                            "untar_options":{"cond_attr":(None,"attrname","If defined, the attribute name used at runtime to determine if the file should be untarred or not.",None),
                                             "dir":(None,"dirname","Subdirectory in which to untar. (defaults to relname up to first .)",None),
                                             "absdir_outattr":(None,"attrname",'Attribute to be set to the abs dir name where the tarball was unpacked. Will be defined only if untar effectively done. (Not defined if None)',None)}}
        
        
        sub_defaults={'attrs':({},'Dictionary of attributes',"Each attribute entry contains:\n"+defdict2string(self.attr_defaults,'\t'),self.attr_defaults),
                      'files':([],'List of files',"Each file entry contains:\n"+defdict2string(self.file_defaults,'\t'),self.file_defaults)}
        self.entry_defaults={"gatekeeper":(None,'gatekeeper', 'Grid gatekeeper/resource',None),
                             "gridtype":('gt2','grid_type','Condor Grid type',None),
                             "rsl":(None,'RSL','Globus RSL option',None),
                             "work_dir":(".",".|Condor|OSG","Where to start glidein",None),
                             'proxy_url':(None,'proxy_url',"Squid cache to use",None),
                             "attrs":sub_defaults['attrs'],
                             "files":sub_defaults['files']}
        
        self.defaults={"factory_name":(socket.gethostname(),'ID', 'Factory name',None),
                       "glidein_name":(None,'ID', 'Glidein name',None),
                       'schedd_name':("schedd_glideins@%s"%socket.gethostname(),"ScheddName","Which schedd to use",None),
                       "submit":{"base_dir":(os.environ["HOME"],"base_dir","Submit base dir",None)},
                       "stage":{"base_dir":("/var/www/html/glidefactory/stage","base_dir","Stage base dir",None),
                                "web_base_url":("http://%s/glidefactory/stage"%socket.gethostname(),'base_url','Base Web server URL',None),
                                "use_symlink":("True","Bool","Can I symlink stage dir from submit dir?",None)},
                       "monitor":{"base_dir":("/var/www/html/glidefactory/stage","base_dir","Monitoring base dir",None)},
                       "condor":{"tar_file":(None,"fname","Tarball containing condor binaries (overrides base_dir if defined)",None),
                                 "base_dir":(find_condor_base_dir(),"base_dir","Condor distribution base dir (used only if tar_file undefined)",None)},
                       "attrs":sub_defaults['attrs'],
                       "files":sub_defaults['files'],
                       "entries":({},"Dictionary of entries","Each entry contains:\n"+defdict2string(self.entry_defaults,'\t'),self.entry_defaults)}
                       
                       
        # support dir
        self.src_dir=os.path.join(os.getcwd(),"web_base")

        try:
            if len(argv)<2:
                raise RuntimeError, "Missing config file"

            self.load_file(argv[1])
            # create derived values
            self.derive()
        except RuntimeError, e:
            self.usage()
            print ""
            print e
            sys.exit(1)
        pass

    def derive(self):
        self.subparams.validate(self.defaults,"glidein")

        # glidein name does not have a reasonable default
        if self.glidein_name==None:
            raise RuntimeError, "Missing glidein name"

        # make a copy of the loaded data, so that I can always tell what was derived and what was not
        self.org_data=copy.deepcopy(self.data)

        self.subparams.use_defaults(self.defaults)

        #print self.org_data
        #print "\n\n",self.data
        #
        #if self.gatekeeper==None:
        #    self.usage()
        #    raise RuntimeError, "Missing gatekeeper"
        # 
        #if self.condor_base_dir==None:
        #    raise RuntimeError, "Missing condor base dir"
        
        glidein_subdir="glidein_%s"%self.glidein_name
        self.stage_dir=os.path.join(self.stage.base_dir,glidein_subdir)
        self.monitor_dir=os.path.join(self.monitor.base_dir,glidein_subdir)
        self.submit_dir=os.path.join(self.submit.base_dir,glidein_subdir)
        self.web_url=os.path.join(self.stage.web_base_url,glidein_subdir)

    #load from a file
    #one element per line
    # -opt val
    def load_file(self,fname):
        if fname=="-":
            fname=sys.stdin
        try:
            self.data=xmlParse.xmlfile2dict(fname)
        except xml.parsers.expat.ExpatError, e:
            raise RuntimeError, "XML error parsing config file: %s"%e
        self.subparams=SubParams(self.data)
        return

    def __getattr__(self,name):
        return self.subparams.__getattr__(name)

    def usage(self):
        print "Usage: create_glidein cfg_fname"

    #save into a file
    #The file should be usable for reload
    # -opt val
    def save_into_file(self,fname):
        fd=open(fname,"w")
        try:
            for el in self.param_desc:
                param_name=el[0]
                if type(param_name)==type(""):
                    # only if a regular parameter
                    param_flag=el[1][-1]
                    exec('param_vals=self.%s'%param_name)
                    if type(param_vals)!=type([]):
                        # treat everything a a list... much easier
                        param_vals=[param_vals]
                    for param_val in param_vals:
                        if param_val!=None:
                          fd.write("%s %s\n"%(param_flag,param_val))
                # else it is a special one that cannot be saved
        finally:
            fd.close()
        return
    

################################################################################

def main(params):
    #print params.__dict__
    create_dir(params.submit_dir)
    try:
        # create log submit subdir
        create_dir(os.path.join(params.submit_dir,"log")) # no try/except needed, will be deleted by external except if needed
        
        create_dir(params.stage_dir)
        try:
            # create entry subdirs for both submit and stage
            for entry_name in params.entries.keys():
                for base_dir in (params.submit_dir,params.stage_dir):
                    entry_dir=os.path.join(base_dir,"entry_"+entry_name)
                    create_dir(entry_dir) # no try/except needed, will be deleted by external except if needed

            create_dir(params.monitor_dir)
            try:
               # make a link from the submit dir to the monitor dir
               symlink_file(params.monitor_dir,os.path.join(params.submit_dir)+"/monitor")

               # put user files in stage
               for file in params.files:
                   copy_file_unparsed(file,params.stage_dir,params.submit_dir)
               ## repeat for all the entries
               for entry_name in params.entries.keys():
                   entry_stage_dir=os.path.join(params.stage_dir,"entry_"+entry_name)
                   entry_submit_dir=os.path.join(params.submit_dir,"entry_"+entry_name)
                   for file in params.entries[entry_name].files:
                       copy_file_unparsed(file,entry_stage_dir,entry_submit_dir)

               #put condor tarball into stage
               if params.condor.tar_file!=None: # condor tarball available
                   condor_uf=SubParams({"absfname":params.condor.tar_file,
                                        "relfname":CONDOR_FILE,
                                        "const":"True",
                                        "untar":"True",
                                        "untar_options":{"cond_attr":None,
                                                         "dir":CONDOR_DIR,
                                                         "absdir_outattr":CONDOR_ATTR}})
                   copy_file_unparsed(condor_uf,params.stage_dir,params.submit_dir)
               else: # create a new tarball
                   create_condor_tar(params.stage_dir,params.submit_dir,params.condor.base_dir)
               
               #put system files into stage
               copy_stage_file("condor_config",params.stage_dir,params.src_dir)
               copy_stage_file("condor_vars.lst",params.stage_dir,params.src_dir)
               copy_stage_file("nodes.blacklist",params.stage_dir,params.src_dir,can_be_modified=1)
               copy_script("setup_x509.sh",params.stage_dir,params.src_dir)
               copy_script("validate_node.sh",params.stage_dir,params.src_dir)
               
               
               # put user attributes into config files
               for attr_name in params.attrs.keys():
                   add_attr_unparsed(attr_name, params.attrs[attr_name],params.stage_dir,params.submit_dir)

               # add the basic standard params
               add_param(params.submit_dir,"GLIDEIN_Collector",'Fake',is_string=True)
               # finalize
               add_attr_files(params.stage_dir,params.submit_dir)

               ## repeat for all the entries
               for entry_name in params.entries.keys():
                   entry_stage_dir=os.path.join(params.stage_dir,"entry_"+entry_name)
                   entry_submit_dir=os.path.join(params.submit_dir,"entry_"+entry_name)
                   for attr_name in params.entries[entry_name].attrs.keys():
                       add_attr_unparsed(attr_name, params.entries[entry_name].attrs[attr_name],entry_stage_dir,entry_submit_dir)
                   add_attr_files(entry_stage_dir,entry_submit_dir)

               # this must be the last script in the list
               copy_script(CONDOR_STARTUP_FILE,params.stage_dir,params.src_dir)
               sha1=finalize_sha1(params.stage_dir,params.submit_dir,"main")
               for entry_name in params.entries.keys():
                   entry_stage_dir=os.path.join(params.stage_dir,"entry_"+entry_name)
                   esha1=finalize_sha1(entry_stage_dir,params.submit_dir,"entry_"+entry_name)

               #
               # Stage is finished
               # Populate submit dir
               #

               # copy the startup file
               copy_submit_file(STARTUP_FILE,params.submit_dir,params.src_dir)

               link_attributes(params.submit_dir,params.stage_dir,bool(params.stage.use_symlink))
               for entry_name in params.entries.keys():
                   entry_stage_dir=os.path.join(params.stage_dir,"entry_"+entry_name)
                   entry_submit_dir=os.path.join(params.submit_dir,"entry_"+entry_name)
                   link_attributes(entry_submit_dir,entry_stage_dir,bool(params.stage.use_symlink))

               create_glidein_descript(params.submit_dir,
                                       params.factory_name,params.glidein_name,
                                       params.schedd_name,
                                       params.web_url,
                                        params.entries.keys())

               create_submit(params.submit_dir,
                             params.factory_name,params.glidein_name,
                             params.schedd_name,
                             params.web_url)

               create_submit_wrapper(params.submit_dir)
               create_test_submit(params.submit_dir)

               #params.save_into_file(os.path.join(params.submit_dir,"glideinWMS.cfg"))

               for entry_name in params.entries.keys():
                   entry_stage_dir=os.path.join(params.stage_dir,"entry_"+entry_name)
                   entry_submit_dir=os.path.join(params.submit_dir,"entry_"+entry_name)
                   entry_el=params.entries[entry_name]
                   create_job_descript(entry_submit_dir,entry_name,
                                       entry_el.gridtype,entry_el.gatekeeper,entry_el.rsl,
                                       entry_el.work_dir,entry_el.proxy_url)
            except:
               shutil.rmtree(params.monitor_dir)
               raise
        except:
            shutil.rmtree(params.stage_dir)
            raise
    except:
        shutil.rmtree(params.submit_dir)
        raise

    print "Created glidein '%s'"%params.glidein_name
    print "Submit files can be found in %s"%params.submit_dir
    print "Support files are in %s"%params.stage_dir
    print "Monitoring files are in %s"%params.monitor_dir


############################################################
#
# P R I V A T E - Do not use
# 
############################################################

ATTRS_FILE="attributes.cfg"
CONSTS_FILE="constants.cfg"
PARAMS_FILE="params.cfg"
SUMMARY_SIGNATURE_FILE="signatures.sha1"

FILE_LISTFILE="file_list.lst"
SCRIPT_LISTFILE="script_list.lst"
SUBSYSTEM_LISTFILE="subsystem_list.lst"
SIGNATURE_FILE="signature.sha1"


CONDOR_FILE="condor_bin.tgz"
CONDOR_DIR="condor"
CONDOR_ATTR="CONDOR_DIR"

STARTUP_FILE="glidein_startup.sh"
GLIDEIN_FILE="glidein.descript"
DESCRIPT_FILE="job.descript"
SUBMIT_FILE="job.condor"
SUBMIT_WRAPPER="job_submit.sh"
CONDOR_STARTUP_FILE="condor_startup.sh"

#####################
# Simply create a dir
def create_dir(dirname):
    try:
        os.mkdir(dirname)
    except OSError, e:
        raise RuntimeError, "Cannot create dir %s: %s"%(dirname,e)

#####################
# Simply copy a file
def copy_file(infile,outfile):
    try:
        shutil.copy2(infile,outfile)
    except IOError, e:
        raise RuntimeError, "Error copying %s in %s: %s"%(infile,outfile,e)
        
#######################
# Simply symlink a file
def symlink_file(infile,outfile):
    try:
        os.symlink(infile,outfile)
    except IOError, e:
        raise RuntimeError, "Error symlink %s in %s: %s"%(infile,outfile,e)
        

########################
# Write a line in a file
def add_line(filename,dir,line):
    filepath=os.path.join(dir,filename)
    try:
        fd=open(filepath,"a+")
    except IOError,e:
        raise RuntimeError, "Error appending to %s: %s"%(filepath,e)
    try:
        fd.write("%s\n"%line)
    finally:
        fd.close()

############################
# Add a published attributed
def add_attr(stage_dir,attr_name,attr_val,is_string):
    if is_string:
        attr_val=repr(attr_val)
    else:
        attr_val=repr(int(attr_val))

    add_line(ATTRS_FILE,stage_dir,"%s \t%s"%(attr_name,attr_val))

############################
# Add a constant attribute
def add_const(stage_dir,attr_name,attr_val):
    add_line(CONSTS_FILE,stage_dir,"%s \t%s"%(attr_name,attr_val))

########################
# Add a parameter
def add_param(submit_dir,param_name,param_defval,is_string):
    if is_string:
        param_defval=repr(param_defval)
    else:
        param_defval=repr(int(param_defval))

    add_line(PARAMS_FILE,submit_dir,"%s \t%s"%(param_name,param_defval))

#################################
# Calculate SHA1 for the file
def calc_sha1(filename,stage_dir):
    filepath=os.path.join(stage_dir,filename)
    try:
        sha1=string.split(exe_cmd("sha1sum %s"%filepath)[0])[0]
    except RuntimeError, e:
        raise RuntimeError, "Error calculating SHA1 for %s: %s"%(filepath,e)
    return sha1

#################################
# Calculate SHA1 for the file and
# put it into the signature file
def add_sha1(filename,stage_dir):
    sha1=calc_sha1(filename,stage_dir)
    add_line(SIGNATURE_FILE,stage_dir,"%s  %s"%(sha1,filename))

#########################
# Register a regular file
def add_file(filename,stage_dir,can_be_modified=0):
    if can_be_modified:
        add_line(FILE_LISTFILE,stage_dir,"%s nocache"%filename)
    else:
        add_sha1(filename,stage_dir)
        add_line(FILE_LISTFILE,stage_dir,filename)

###################
# Register a script
def add_script(filename,stage_dir):
    add_sha1(filename,stage_dir)
    add_line(SCRIPT_LISTFILE,stage_dir,filename)

######################
# Register a subsystem
def add_subsystem(filename,stage_dir,submit_dir,config_check,wnsubdir,config_out):
    if config_check==None:
        config_check="TRUE" #TRUE has a special meaning for the glidein
    add_sha1(filename,stage_dir)
    add_line(SUBSYSTEM_LISTFILE,stage_dir,"%s %s %s %s"%(config_check,wnsubdir,filename,config_out))
    if config_check!="TRUE":
        # TRUE is not a real parameter, so no need to log it
        add_param(submit_dir,config_check,0,is_string=False) # if it is optional, default==0

##########################################
# Calculate SHA1 for the list files
# Return the sha1sum of the signature file
def finalize_sha1(stage_dir,submit_dir,title):
    for f in (FILE_LISTFILE,SCRIPT_LISTFILE,SUBSYSTEM_LISTFILE):
        # touch the file, in case it does not exist
        filepath=os.path.join(stage_dir,f)
        try:
            fd=open(filepath,"a+")
        except IOError,e:
            raise RuntimeError, "Error appending to %s: %s"%(filepath,e)
        fd.close()
        # calc sha1
        add_sha1(f,stage_dir)
    sha1=calc_sha1(SIGNATURE_FILE,stage_dir)
    add_line(SUMMARY_SIGNATURE_FILE,submit_dir,"%s  %s"%(sha1,title))
    return sha1
    
#####################
# Copy a regular file
def copy_stage_file(filename,stage_dir,org_dir,can_be_modified=0):
    copy_file(os.path.join(org_dir,filename),stage_dir)
    add_file(filename,stage_dir,can_be_modified)

###############
# Copy a script
def copy_script(filename,stage_dir,org_dir):
    copy_file(os.path.join(org_dir,filename),stage_dir)
    add_script(filename,stage_dir)

######################
# Copy a subsystem
def copy_subsystem(filename,stage_dir,submit_dir,org_dir,config_check,wnsubdir,config_out):
    copy_file(os.path.join(org_dir,filename),stage_dir)
    add_subsystem(filename,stage_dir,submit_dir,config_check,wnsubdir,config_out)

#####################
# Copy a user file
# file as described by Params.file_defaults
def copy_file_unparsed(file,stage_dir,submit_dir):
    if file.absfname==None:
        raise RuntimeError, "Found a file element without a absname: %s"%file
    
    relfname=file.relfname
    if relfname==None:
        relfname=os.path.basename(file.absfname) # defualt is the final part of absfname
    if len(relfname)<1:
        raise RuntimeError, "Found a file element with an empty relfname: %s"%file

    copy_file(file.absfname,os.path.join(stage_dir,relfname))
    
    is_const=eval(file.const,{},{})
    is_executable=eval(file.executable,{},{})
    do_untar=eval(file.untar,{},{})

    if is_executable: # a script
        if not is_const:
            raise RuntimeError, "A file cannot be executable if it is not constant: %s"%file
    
        if do_untar:
            raise RuntimeError, "A tar file cannot be executable: %s"%file

        add_script(relfname,stage_dir)
    elif do_untar: # a tarball
        if not is_const:
            raise RuntimeError, "A file cannot be untarred if it is not constant: %s"%file

        wnsubdir=file.untar_options.dir
        if wnsubdir==None:
            wnsubdir=string.split(relfname,'.',1)[0] # deafult is relfname up to the first .

        #temporary, should be fixed in future versions
        if file.untar_options.absdir_outattr==None:
            raise RuntimeError, 'Currently untar_options.absdir_outattr must be defined: %s'%file
        
        add_subsystem(relfname,stage_dir,submit_dir,file.untar_options.cond_attr,wnsubdir,file.untar_options.absdir_outattr)
    else: # not executable nor tarball => simple file
        add_file(relfname,stage_dir,not is_const)


#######################
# Register an attribute
# attr_obj as described by Params.attr_defaults
def add_attr_unparsed(attr_name,attr_obj,stage_dir,submit_dir):
    if attr_obj.value==None:
        raise RuntimeError, "Attribute '%s' does not have a value: %s"%(attr_name,attr_obj)
    
    do_publish=eval(attr_obj.publish,{},{})
    is_parameter=eval(attr_obj.parameter,{},{})
    is_const=eval(attr_obj.const,{},{})

    if (not attr_obj.type in ("string","int")):
        raise RuntimeError, "Wrong type '%s' for attribute '%s', must be either 'int' or 'string'"%(attr_obj.type,attr_name)
    
    if do_publish: # publish in factory ClassAd
        if is_parameter: # but also push to glidein
            if is_const:
                add_attr(stage_dir,attr_name,attr_obj.value,attr_obj.type=="string")
                add_const(stage_dir,attr_name,attr_obj.value)
            else:
                add_param(submit_dir,attr_name,attr_obj.value,attr_obj.type=="string")
        else: # only publish
            if (not is_const):
                raise RuntimeError, "Published attribute '%s' must be either a parameter or constant: %s"%(attr_name,attr_obj)
            
            add_attr(stage_dir,attr_name,attr_obj.value,attr_obj.type=="string")
    else: # do not publish, only to glidein
        if is_parameter:
            if is_const:
                add_const(stage_dir,attr_name,attr_obj.value)
            else:
                raise RuntimeError, "Parameter attributes '%s' must be either a published or constant: %s"%(attr_name,attr_obj)
        else:
            raise RuntimeError, "Attributes '%s' must be either a published or parameters: %s"%(attr_name,attr_obj) 
    
#############################################
# Register the files that host the attributes
def add_attr_files(stage_dir,submit_dir):
    global ATTRS_FILE,CONSTS_FILE,PARAMS_FILE
    for fname in (ATTRS_FILE,CONSTS_FILE):
        # touch the file, in case it does not exist
        filepath=os.path.join(stage_dir,fname)
        try:
            fd=open(filepath,"a+")
        except IOError,e:
            raise RuntimeError, "Error appending to %s: %s"%(filepath,e)
        fd.close()
        # register it
        add_file(fname,stage_dir,0)
    # also make sure that the params file exist
    filepath=os.path.join(submit_dir,PARAMS_FILE)
    try:
        fd=open(filepath,"a+")
    except IOError,e:
        raise RuntimeError, "Error appending to %s: %s"%(filepath,e)
    fd.close()

     
##############################
# Execute a command in a shell
def exe_cmd(cmd):
    childout, childin, childerr = popen2.popen3(cmd)
    childin.close()
    tempOut = childout.readlines()
    childout.close()
    tempErr = childerr.readlines()
    childerr.close()
    if (len(tempErr)!=0):
        raise RuntimeError, "Error running '%s'\n%s"%(cmd,tempErr)
    return tempOut


##############################
# Create condor tarball and
# add it to the list of subsaystems
def create_condor_tar(stage_dir,submit_dir,condor_base_dir):
    global CONDOR_FILE,CONDOR_DIR,CONDOR_ATTR
    tgz_name=CONDOR_FILE
    outtar_name=os.path.join(stage_dir,tgz_name)
    condor_sbin_dir=os.path.join(condor_base_dir,"sbin")
    try:
        if not os.path.isdir(condor_sbin_dir):
            raise RuntimeError, "%s is not a directory"%condor_sbin_dir
        exe_cmd('cd "%s"; tar -czf "%s" condor_master condor_startd condor_starter'%(condor_sbin_dir,outtar_name))
        
        add_subsystem(tgz_name,stage_dir,submit_dir,None,CONDOR_DIR,CONDOR_ATTR)
    except RuntimeError, e:
        raise RuntimeError, "Error creating condor tgz: %s"%e


###################################
# Create a copy or a link in the
# submit dir
def link_attributes(submit_dir,stage_dir,do_softlink):
    global ATTRS_FILE
    submit_filepath=os.path.join(submit_dir,ATTRS_FILE)
    stage_filepath=os.path.join(stage_dir,ATTRS_FILE)

    if do_softlink:
        symlink_file(stage_filepath,submit_filepath)
    else:
        copy_file(stage_filepath,submit_filepath)
        # Make it read only
        os.chmod(filepath,0444)

#####################################
# try to find out the base condor dir
def find_condor_base_dir():
    condor_base_path=None
    # try using condor commands to find it out
    try:
        condor_base_path=exe_cmd("condor_config_val RELEASE_DIR")[0][:-1] # remove trailing newline
    except RuntimeError,e:
        # try to find the SBIN, and append go one down
        try:
            release_path=exe_cmd("condor_config_val SBIN")
            condor_base_path=os.path.join(release_path[0][:-1],"..")
        except RuntimeError,e:
            # look for condor_config in /etc
            if os.environ.has_key("CONDOR_CONFIG"):
                condor_config=os.environ["CONDOR_CONFIG"]
            else:
                condor_config="/etc/condor/condor_config"
                
            try:
                # BIN = <path>
                bin_def=exe_cmd('grep "^ *RELEASE_DIR" %s'%condor_config)
                condor_base_path=string.split(bin_def[0][:-1])[2]
            except RuntimeError, e:
                try:
                    # RELEASE_DIR = <path>
                    release_def=exe_cmd('grep "^ *SBIN" %s'%condor_config)
                    condor_base_path=os.path.join(string.split(release_def[0][:-1])[2],"..")
                except RuntimeError, e:
                    pass # don't know what else to try
    return condor_base_path

#####################
# Copy a regular file
def copy_submit_file(filename,submit_dir,org_dir):
    copy_file(os.path.join(org_dir,filename),submit_dir)

#################################
# Create glidein description file
def create_glidein_descript(submit_dir,
                            factory_name,glidein_name,
                            schedd_name,web_base,
                            entries):
    global GLIDEIN_FILE
    filepath=os.path.join(submit_dir,GLIDEIN_FILE)
    try:
        fd=open(filepath,"w+")
    except IOError,e:
        raise RuntimeError, "Error creating %s: %s"%(filepath,e)
    try:
        fd.write("FactoryName   %s\n"%factory_name)
        fd.write("GlideinName   %s\n"%glidein_name)
        fd.write("Schedd        %s\n"%schedd_name)
        fd.write("WebURL        %s\n"%web_base)
        fd.write("Entries       %s\n"%string.join(entries,","))
    finally:
        fd.close()
    
#################################
# Create glidein description file
def create_job_descript(submit_dir,
                        entry_name,
                        gridtype,gatekeeper,rsl,
                        startup_dir,proxy_id):
    global DESCRIPT_FILE
    filepath=os.path.join(submit_dir,DESCRIPT_FILE)
    try:
        fd=open(filepath,"w+")
    except IOError,e:
        raise RuntimeError, "Error creating %s: %s"%(filepath,e)
    try:
        fd.write("EntryName     %s\n"%entry_name)
        fd.write("GridType      %s\n"%gridtype)
        fd.write("Gatekeeper    %s\n"%gatekeeper)
        if rsl!=None:
            fd.write("GlobusRSL     %s\n"%rsl)
        fd.write("StartupDir    %s\n"%startup_dir)
        if proxy_id!=None:
            fd.write("ProxyURL      %s\n"%proxy_id)
    finally:
        fd.close()
    
###########################
# Create Condor submit file
def create_submit(submit_dir,
                  factory_name,glidein_name,
                  schedd_name,
                  web_base):
    global SUBMIT_FILE
    filepath=os.path.join(submit_dir,SUBMIT_FILE)
    try:
        fd=open(filepath,"w+")
    except IOError,e:
        raise RuntimeError, "Error creating %s: %s"%(filepath,e)
    try:
        fd.write("Universe = grid\n")
        fd.write("Grid_Resource = $ENV(GLIDEIN_GRIDTYPE) $ENV(GLIDEIN_GATEKEEPER)\n")
        fd.write("Executable = %s\n"%STARTUP_FILE)

        fd.write(("Arguments = -v $ENV(GLIDEIN_VERBOSITY) -cluster $(Cluster) -name %s -entry $ENV(GLIDEIN_ENTRY_NAME) -subcluster $(Process) -schedd %s "%(glidein_name,schedd_name))+
                 ("-web %s -sign $ENV(GLIDEIN_SIGN) -signentry $ENV(GLIDEIN_SIGNENTRY) -signtype sha1 -factory %s -consts %s -glidescript %s " % (web_base,factory_name,CONSTS_FILE,CONDOR_STARTUP_FILE))+
                 "-param_GLIDEIN_Client $ENV(GLIDEIN_CLIENT) $ENV(GLIDEIN_PARAMS)\n")
        fd.write('+GlideinFactory    = "%s"\n'%factory_name)
        fd.write('+GlideinName       = "%s"\n'%glidein_name)
        fd.write('+GlideinEntryName  = "$ENV(GLIDEIN_ENTRY_NAME)"\n')
        fd.write('+GlideinClient     = "$ENV(GLIDEIN_CLIENT)"\n')

        
        fd.write("\nTransfer_Executable   = True\n")
        fd.write("transfer_Input_files  =\n")
        fd.write("transfer_Output_files =\n")
        fd.write("WhenToTransferOutput  = ON_EXIT\n")
        fd.write("\nNotification = Never\n")
        fd.write("\n+Owner = undefined\n")
        fd.write("\nLog = log/condor_activity_$ENV(GLIDEIN_LOGNR)_$ENV(GLIDEIN_CLIENT).log\n")
        fd.write("Output = log/job.$(Cluster).$(Process).out\n")
        fd.write("Error = log/job.$(Cluster).$(Process).err\n")
        fd.write("stream_output = False\n")
        fd.write("stream_error  = False\n")
        fd.write("\nQueue $ENV(GLIDEIN_COUNT)\n")
    finally:
        fd.close()
    
############################
# Create a test shell script
def create_test_submit(submit_dir):
    global SUBMIT_FILE,GLIDEIN_FILE,DESCRIPT_FILE
    filepath=os.path.join(submit_dir,"job_test.sh")
    try:
        fd=open(filepath,"w+")
    except IOError,e:
        raise RuntimeError, "Error creating %s: %s"%(filepath,e)
    try:
        fd.write("#!/bin/bash\n")
        fd.write("export GLIDEIN_CLIENT=test\n")
        fd.write("export GLIDEIN_COUNT=1\n")
        fd.write("export GLIDEIN_VERBOSITY=dbg\n")
        fd.write('export GLIDEIN_PARAMS="-param_GLIDEIN_Collector $HOSTNAME"\n')
        fd.write('export GLIDEIN_LOGNR=`date +%Y%m%d`\n')
        fd.write("export GLIDEIN_ENTRY_NAME=test\n")
        fd.write("export GLIDEIN_SIGN=`awk '/ main$/{print $1}' %s`\n"%SUMMARY_SIGNATURE_FILE)
        fd.write('export GLIDEIN_SIGNENTRY=`awk "/ entry_$GLIDEIN_ENTRY_NAME\$"\'/{print $1}\' %s`\n'%SUMMARY_SIGNATURE_FILE)
        fd.write("export GLIDEIN_GRIDTYPE `grep '^GridType' entry_$GLIDEIN_ENTRY_NAME/%s|awk '{print $2}'`\n"%DESCRIPT_FILE)
        fd.write("export GLIDEIN_GATEKEEPER `grep '^Gatekeeper' entry_$GLIDEIN_ENTRY_NAME/%s|awk '{print $2}'`\n"%DESCRIPT_FILE)
        fd.write("condor_submit -name `grep '^Schedd' %s|awk '{print $2}'` %s\n"%(GLIDEIN_FILE,SUBMIT_FILE))
    finally:
        fd.close()
    # Make it executable
    os.chmod(filepath,0755)
    
############################
# Create a submit wrapper 
def create_submit_wrapper(submit_dir):
    global SUBMIT_WRAPPER,SUBMIT_FILE
    filepath=os.path.join(submit_dir,SUBMIT_WRAPPER)
    try:
        fd=open(filepath,"w+")
    except IOError,e:
        raise RuntimeError, "Error creating %s: %s"%(filepath,e)
    try:
        fd.write("#!/bin/bash\n\n")
        fd.write("if [ $# -lt 8 ]; then\n")
        fd.write(' echo "At least 8 args expected!" 1>&2\n echo "Usage: %s entry_name schedd client count mode gridtype gatekeeper gridopts [params]*"\n 1>&2\n'%SUBMIT_WRAPPER)
        fd.write(" exit 1\n")
        fd.write("fi\n")
        fd.write('export GLIDEIN_ENTRY_NAME="$1"\nshift\n')
        fd.write("schedd=$1\nshift\n")
        fd.write('export GLIDEIN_CLIENT="$1"\nshift\n')
        fd.write("export GLIDEIN_COUNT=$1\nshift\n")
        fd.write("export GLIDEIN_VERBOSITY=$1\nshift\n")
        fd.write("export GLIDEIN_GRIDTYPE=$1\nshift\n")
        fd.write('export GLIDEIN_GATEKEEPER="$1"\nshift\n')
        fd.write('GLIDEIN_GRIDOPTS="$1"\nshift\n')
        fd.write('GLIDEIN_PARAMS=""\n')
        fd.write('while [ "$1" != "--" ]; do\n GLIDEIN_PARAMS="$GLIDEIN_PARAMS $1"\n shift\ndone\nshift # remove --\n')
        fd.write('while [ $# -ge 2 ]; do\n GLIDEIN_PARAMS="$GLIDEIN_PARAMS -param_$1 $2"\n shift\n shift\ndone\nexport GLIDEIN_PARAMS\n')
        fd.write('export GLIDEIN_LOGNR=`date +%Y%m%d`\n')
        fd.write("export GLIDEIN_SIGN=`awk '/ main$/{print $1}' %s`\n"%SUMMARY_SIGNATURE_FILE)
        fd.write('export GLIDEIN_SIGNENTRY=`awk "/ entry_$GLIDEIN_ENTRY_NAME\$/"\'{print $1}\' %s`\n'%SUMMARY_SIGNATURE_FILE)
        fd.write('condor_submit -append "$GLIDEIN_GRIDOPTS" -name $schedd %s\n'%SUBMIT_FILE)
    finally:
        fd.close()
    # Make it executable
    os.chmod(filepath,0755)

def defdict2string(defaults,indent):
    outstrarr=[]

    for k in defaults.keys():
        el=defaults[k]
        if type(el)==type({}):  #sub-dictionary
            outstrarr.append("%s%s:\n%s"%(indent,k,defdict2string(el,indent+"\t")))
        else:
            #print el
            defvalue,ktype,txt,subdef=el
            if subdef!=None:
                outstrarr.append("%s%s(%s) - [%s] %s:\n%s"%(indent,k,ktype,defvalue,txt,defdict2string(subdef,indent+"\t")))
            else:
                outstrarr.append("%s%s(%s) - %s [%s]"%(indent,k,ktype,txt,defvalue))
    return string.join(outstrarr,"\n")
    
############################################################
#
# S T A R T U P
# 
############################################################

if __name__ == '__main__':
    params=Params(sys.argv)
    try:
        main(params)
    except RuntimeError, e:
        params.usage()
        print ""
        print e
