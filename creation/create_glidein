#!/bin/env python

import popen2
import os
import copy
import sys
import os.path
import string
import shutil
import traceback
sys.path.append("lib")
import cgWParams
import cgWDictFile
import cgWConsts
import cgWCreate


################################################################################

def main(params):
    #print params.__dict__
    create_dir(params.submit_dir)
    try:
        # create log submit subdir
        create_dir(os.path.join(params.submit_dir,"log")) # no try/except needed, will be deleted by external except if needed

        # create entry dirs, including internal log dirs
        for entry_name in params.entries.keys():
            entry_dir=cgWConsts.get_entry_submit_dir(params.submit_dir,entry_name)
            create_dir(entry_dir)
            create_dir(os.path.join(entry_dir,"log"))
        
        create_dir(params.stage_dir)
        try:
            # create entry dirs
            for entry_name in params.entries.keys():
                entry_dir=cgWConsts.get_entry_stage_dir(params.stage_dir,entry_name)
                create_dir(entry_dir) # no try/except needed, will be deleted by external except if needed

            create_dir(params.monitor_dir)
            try:
               # create entry dirs
               for entry_name in params.entries.keys():
                   entry_dir=cgWConsts.get_entry_monitor_dir(params.monitor_dir,entry_name)
                   create_dir(entry_dir) # no try/except needed, will be deleted by external except if needed
                    
               # make a link from the submit dir to the monitor dir
               symlink_file(params.monitor_dir,os.path.join(params.submit_dir)+"/monitor")

               # create dictionary variables
               glidein_dicts_obj=cgWDictFile.glideinDicts(params.submit_dir,params.stage_dir,params.entries.keys())
               ## keep separate variables for now (legacy code)
               main_dicts=glidein_dicts_obj.main_dicts
               entry_dicts=glidein_dicts_obj.entry_dicts

               # Load initial system scripts
               # These should be executed before the other scripts
               for script_name in ('setup_x509.sh',"validate_node.sh"):
                   main_dicts['script_list'].add_from_file(script_name,None,os.path.join(params.src_dir,script_name))
                   

               # put user files in stage
               for file in params.files:
                   add_file_unparsed(file,main_dicts)
               ## repeat for all the entries
               for entry_name in params.entries.keys():
                   entry_stage_dir=cgWConsts.get_entry_stage_dir(params.stage_dir,entry_name)
                   for file in params.entries[entry_name].files:
                       add_file_unparsed(file,entry_dicts[entry_name])

               #load condor tarball
               if params.condor.tar_file!=None: # condor tarball available
                   main_dicts['subsystem_list'].add_from_file(cgWConsts.CONDOR_FILE,("TRUE",cgWConsts.CONDOR_DIR,cgWConsts.CONDOR_ATTR),params.condor.tar_file)
               else: # create a new tarball
                   condor_fd=cgWCreate.create_condor_tar_fd(params.condor.base_dir)
                   main_dicts['subsystem_list'].add_from_fd(cgWConsts.CONDOR_FILE,("TRUE",cgWConsts.CONDOR_DIR,cgWConsts.CONDOR_ATTR),condor_fd)
                   condor_fd.close()
               
               #load system files
               for file_name in ('parse_starterlog.awk',"condor_config"):
                   main_dicts['file_list'].add_from_file(file_name,None,os.path.join(params.src_dir,file_name))
               main_dicts['vars'].load(params.src_dir,'condor_vars.lst',change_self=False) # will be modified when attrs processed
               
                ## repeat for all the entries
               for entry_name in params.entries.keys():
                   entry_stage_dir=cgWConsts.get_entry_stage_dir(params.stage_dir,entry_name)
                   entry_dicts[entry_name]['vars'].load(params.src_dir,'condor_vars.lst.entry',change_self=False) # will be modified when attrs processed
                   for file_name in ("nodes.blacklist",):
                       entry_dicts[entry_name]['file_list'].add_from_file(file_name,"nocache",os.path.join(params.src_dir,file_name))
              
               # put user attributes into config files
               for attr_name in params.attrs.keys():
                   add_attr_unparsed(attr_name, params.attrs[attr_name],main_dicts,"main")

               # add the basic standard params
               add_param(main_dicts,"GLIDEIN_Collector",'Fake',is_string=True)

               # this must be the last script in the list
               for script_name in (cgWConsts.CONDOR_STARTUP_FILE,):
                   main_dicts['script_list'].add_from_file(script_name,None,os.path.join(params.src_dir,script_name))
               main_dicts['description'].add(cgWConsts.CONDOR_STARTUP_FILE,"last_script")

               # finalize
               glidein_dicts_obj.save()
               glidein_dicts_obj.set_readonly(True)

               #
               # Stage is finished
               # Populate submit dir
               #

               # copy the startup file
               copy_submit_file(cgWConsts.STARTUP_FILE,params.submit_dir,params.src_dir)

               link_attributes(params.submit_dir,params.stage_dir,bool(params.stage.use_symlink))
               for entry_name in params.entries.keys():
                   entry_stage_dir=cgWConsts.get_entry_stage_dir(params.stage_dir,entry_name)
                   entry_submit_dir=cgWConsts.get_entry_submit_dir(params.submit_dir,entry_name)
                   link_attributes(entry_submit_dir,entry_stage_dir,bool(params.stage.use_symlink))

               cgWCreate.create_glidein_descript(params.submit_dir,
                                                 params.factory_name,params.glidein_name,
                                                 params.web_url,
                                                 params.entries.keys())

               cgWCreate.create_submit(params.submit_dir,
                                       params.factory_name,params.glidein_name,
                                       params.web_url)

               cgWCreate.create_submit_wrapper(params.submit_dir)
               cgWCreate.create_test_submit(params.submit_dir)

               params.save_into_file(os.path.join(params.submit_dir,cgWConsts.XML_CONFIG_FILE))

               global_schedd_names=string.split(params.schedd_name,',')
               global_schedd_idx=0
               for entry_name in params.entries.keys():
                   entry_stage_dir=cgWConsts.get_entry_stage_dir(params.stage_dir,entry_name)
                   entry_submit_dir=cgWConsts.get_entry_submit_dir(params.submit_dir,entry_name)
                   entry_el=params.entries[entry_name]

                   schedd_name=entry_el.schedd_name
                   if schedd_name==None:
                       # use one of the global ones if specific not provided
                       schedd_name=global_schedd_names[global_schedd_idx%len(global_schedd_names)]
                       global_schedd_idx=global_schedd_idx+1
                   
                   cgWCreate.create_job_descript(entry_submit_dir,entry_name,
                                                 entry_el.gridtype,entry_el.gatekeeper,entry_el.rsl,
                                                 schedd_name,
                                                 entry_el.work_dir,entry_el.proxy_url)

            except:
               shutil.rmtree(params.monitor_dir)
               raise
        except:
            shutil.rmtree(params.stage_dir)
            raise
    except:
        shutil.rmtree(params.submit_dir)
        raise

    print "Created glidein '%s'"%params.glidein_name
    print "Submit files can be found in %s"%params.submit_dir
    print "Support files are in %s"%params.stage_dir
    print "Monitoring files are in %s"%params.monitor_dir


############################################################
#
# P R I V A T E - Do not use
# 
############################################################


#####################
# Simply create a dir
def create_dir(dirname):
    try:
        os.mkdir(dirname)
    except OSError, e:
        raise RuntimeError, "Cannot create dir %s: %s"%(dirname,e)

#####################
# Simply copy a file
def copy_file(infile,outfile):
    try:
        shutil.copy2(infile,outfile)
    except IOError, e:
        raise RuntimeError, "Error copying %s in %s: %s"%(infile,outfile,e)
        
#######################
# Simply symlink a file
def symlink_file(infile,outfile):
    try:
        os.symlink(infile,outfile)
    except IOError, e:
        raise RuntimeError, "Error symlink %s in %s: %s"%(infile,outfile,e)
        

########################
# Write a line in a file
def add_line(filename,dir,line):
    filepath=os.path.join(dir,filename)
    try:
        fd=open(filepath,"a+")
    except IOError,e:
        raise RuntimeError, "Error appending to %s: %s"%(filepath,e)
    try:
        fd.write("%s\n"%line)
    finally:
        fd.close()

############################
# Add a published attributed
def add_attr(dicts,attr_name,attr_val,is_string):
    if is_string:
        attr_val=repr(attr_val)
    else:
        attr_val=repr(int(attr_val))

    dicts['attrs'].add(attr_name,attr_val)


############################
# Add a constant attribute
def add_const(dicts,attr_name,attr_val):
    dicts['consts'].add(attr_name,attr_val)

########################
# Add a parameter
def add_param(dicts,param_name,param_defval,is_string):
    if is_string:
        param_defval=repr(param_defval)
    else:
        param_defval=repr(int(param_defval))

    dicts['params'].add(param_name,param_defval)

#################################
# Add a new variable to VARS_FILE
def add_var(dicts,attr_name,is_string,do_glidein_publish,do_job_publish):
    type_str={True:"S",False:"I"}
    glide_str={True:"Y",False:"N"}
    job_str={True:"+",False:"-"}
    dicts['vars'].add(attr_name,(type_str[is_string],'-','+','N',glide_str[do_glidein_publish],job_str[do_job_publish]))
    
#############################################
# Add a user file residing in the stage area
# file as described by Params.file_defaults
def add_file_unparsed(file,dicts):
    absfname=file.absfname
    if absfname==None:
        raise RuntimeError, "Found a file element without an absname: %s"%file
    
    relfname=file.relfname
    if relfname==None:
        relfname=os.path.basename(absfname) # defualt is the final part of absfname
    if len(relfname)<1:
        raise RuntimeError, "Found a file element with an empty relfname: %s"%file

    is_const=eval(file.const,{},{})
    is_executable=eval(file.executable,{},{})
    do_untar=eval(file.untar,{},{})

    if is_executable: # a script
        if not is_const:
            raise RuntimeError, "A file cannot be executable if it is not constant: %s"%file
    
        if do_untar:
            raise RuntimeError, "A tar file cannot be executable: %s"%file

        dicts['script_list'].add_from_file(relfname,None,absfname)
    elif do_untar: # a tarball
        if not is_const:
            raise RuntimeError, "A file cannot be untarred if it is not constant: %s"%file

        wnsubdir=file.untar_options.dir
        if wnsubdir==None:
            wnsubdir=string.split(relfname,'.',1)[0] # deafult is relfname up to the first .

        #temporary, should be fixed in future versions
        if file.untar_options.absdir_outattr==None:
            raise RuntimeError, 'Currently untar_options.absdir_outattr must be defined: %s'%file
        
        cond_attr=file.untar_options.cond_attr
        dicts['subsystem_list'].add_from_file(relfname,(cond_attr,wnsubdir,file.untar_options.absdir_outattr),absfname)
        if cond_attr!="TRUE":
            dicts['params'].add(cond_attr,repr(0))
    else: # not executable nor tarball => simple file
        if is_const:
            val=None
        else:
            val='nocache'
        dicts['file_list'].add_from_file(relfname,val,absfname)


#######################
# Register an attribute
# attr_obj as described by Params.attr_defaults
def add_attr_unparsed(attr_name,attr_obj,dicts,description):
    try:
        add_attr_unparsed_real(attr_name,attr_obj,dicts)
    except RuntimeError,e:
        raise RuntimeError, "Error parsing attr %s[%s]: %s"%(description,attr_name,str(e))

def add_attr_unparsed_real(attr_name,attr_obj,dicts):
    if attr_obj.value==None:
        raise RuntimeError, "Attribute '%s' does not have a value: %s"%(attr_name,attr_obj)
    
    do_publish=eval(attr_obj.publish,{},{})
    is_parameter=eval(attr_obj.parameter,{},{})
    is_const=eval(attr_obj.const,{},{})

    if (not attr_obj.type in ("string","int")):
        raise RuntimeError, "Wrong type '%s' for attribute '%s', must be either 'int' or 'string'"%(attr_obj.type,attr_name)
    
    if do_publish: # publish in factory ClassAd
        if is_parameter: # but also push to glidein
            if is_const:
                add_attr(dicts,attr_name,attr_obj.value,attr_obj.type=="string")
                add_const(dicts,attr_name,attr_obj.value)
            else:
                add_param(dicts,attr_name,attr_obj.value,attr_obj.type=="string")
        else: # only publish
            if (not is_const):
                raise RuntimeError, "Published attribute '%s' must be either a parameter or constant: %s"%(attr_name,attr_obj)
            
            add_attr(dicts,attr_name,attr_obj.value,attr_obj.type=="string")
    else: # do not publish, only to glidein
        if is_parameter:
            if is_const:
                add_const(dicts,attr_name,attr_obj.value)
            else:
                raise RuntimeError, "Parameter attributes '%s' must be either a published or constant: %s"%(attr_name,attr_obj)
        else:
            raise RuntimeError, "Attributes '%s' must be either a published or parameters: %s"%(attr_name,attr_obj) 

    if is_parameter:
        do_glidein_publish=eval(attr_obj.glidein_publish,{},{})
        do_job_publish=eval(attr_obj.job_publish,{},{})

        if do_glidein_publish or do_job_publish:
            # need to add a line only if will be published
            if dicts['vars'].has_key(attr_name):
                # already in the var file, check if compatible
                attr_var_el=dicts['vars'][attr_name]
                attr_var_type=attr_var_el[0]
                if (((attr_obj.type=="int") and (attr_var_type!='I')) or
                    ((attr_obj.type=="string") and (attr_var_type=='I'))):
                    raise RuntimeError, "Types not compatible (%s,%s)"%(attr_obj.type,attr_var_type)
                attr_var_export=attr_var_el[4]
                if do_glidein_publish and (attr_var_export=='N'):
                    raise RuntimeError, "Cannot force glidein publishing"
                attr_var_job_publish=attr_var_el[5]
                if do_job_publish and (attr_var_job_publish=='-'):
                    raise RuntimeError, "Cannot force job publishing"
            else:
                add_var(dicts,attr_name,attr_obj.type=="string",do_glidein_publish,do_job_publish)

###################################
# Create a copy or a link in the
# submit dir
def link_attributes(submit_dir,stage_dir,do_softlink):
    submit_filepath=os.path.join(submit_dir,cgWConsts.ATTRS_FILE)
    stage_filepath=os.path.join(stage_dir,cgWConsts.ATTRS_FILE)

    if do_softlink:
        symlink_file(stage_filepath,submit_filepath)
    else:
        copy_file(stage_filepath,submit_filepath)
        # Make it read only
        os.chmod(filepath,0444)

#####################
# Copy a regular file
def copy_submit_file(filename,submit_dir,org_dir):
    copy_file(os.path.join(org_dir,filename),submit_dir)

    
############################################################
#
# S T A R T U P
# 
############################################################

if __name__ == '__main__':
    try:
        params=cgWParams.Params(sys.argv)
    except RuntimeError,e:
        print e
        sys.exit(1)
    try:
        main(params)
    except RuntimeError, e:
        print params.usage()
        print ""
        print e

###########################################################
#
# CVS info
#
# $Id: create_glidein,v 1.108 2007/12/11 18:08:44 sfiligoi Exp $
#
# Log:
#  $Log: create_glidein,v $
#  Revision 1.108  2007/12/11 18:08:44  sfiligoi
#  Simplify condor tgz handling
#
#  Revision 1.106  2007/12/11 17:39:01  sfiligoi
#  Simplify file management
#
#  Revision 1.105  2007/12/11 15:35:34  sfiligoi
#  Make condor in memory
#
#  Revision 1.103  2007/12/10 21:23:14  sfiligoi
#  Move sha1 calculations at the final stage
#
#  Revision 1.102  2007/12/10 19:38:18  sfiligoi
#  Put file handling in cgWDictFile
#
#  Revision 1.101  2007/12/04 23:58:13  sfiligoi
#  Move setup_x509.sh and validate_node.sh before the other scripts
#
#  Revision 1.100  2007/12/03 21:56:48  sfiligoi
#  Use the cgWDictFile save method
#
#  Revision 1.99  2007/12/03 20:21:22  sfiligoi
#  Update save_dict_files to account for the auto description setup
#
#  Revision 1.98  2007/12/03 20:15:53  sfiligoi
#  Get rid of create_description_file as it is not needed anymore
#
#  Revision 1.97  2007/11/30 22:49:06  sfiligoi
#  Make changing of self optional in load
#
#  Revision 1.96  2007/11/28 21:28:58  sfiligoi
#  Use cgWDictFile.glideinDicts
#
#  Revision 1.95  2007/11/28 20:52:23  sfiligoi
#  Use get_entry_monitor_dir
#
#  Revision 1.94  2007/11/27 19:58:51  sfiligoi
#  Move dicts initialization into cgWDictFile and entry subdir definition in cgWConsts
#
#  Revision 1.93  2007/10/25 22:30:27  sfiligoi
#  Use cgWDictFile
#
#  Revision 1.92  2007/10/18 19:06:26  sfiligoi
#  Mayor restructuring to get all the file creation more structured
#
#  Revision 1.91  2007/10/16 15:50:59  sfiligoi
#  Split file addition from file copying
#
#  Revision 1.90  2007/10/12 21:56:24  sfiligoi
#  Add glideinWMS.cfg in the list of constants
#
#  Revision 1.89  2007/10/12 21:41:45  sfiligoi
#  Proper error message handling
#
#  Revision 1.87  2007/10/12 21:22:56  sfiligoi
#  Remove the use of sys.exit
#
#  Revision 1.85  2007/10/12 21:01:17  sfiligoi
#  Moved consts and creation funcs into dedicated modules
#
#  Revision 1.84  2007/10/12 19:27:04  sfiligoi
#  Moved cgWParams to lib subdir
#
#  Revision 1.83  2007/10/12 19:18:48  sfiligoi
#  Move find_condor_base_dir to the right place
#
#  Revision 1.82  2007/10/12 19:11:12  sfiligoi
#  Put config file parsing in a separate module
#
#  Revision 1.81  2007/07/18 22:38:30  sfiligoi
#  Add printout from parsing Condor StarterLog
#
#  Revision 1.80  2007/07/11 23:46:32  sfiligoi
#  Put description_file name into signatures.cfg
#
#  Revision 1.79  2007/07/11 22:55:19  sfiligoi
#  Rename DESCRIPT_FILE into JOB_DESCRIPT_FILE to prevent confision with the new DESCRIPTION_FILE
#
#  Revision 1.78  2007/07/11 21:57:31  sfiligoi
#  Add inital support for several versions of files in the stage area
#
#  Revision 1.77  2007/05/18 20:35:05  sfiligoi
#  Fix submit file to handle multiple schedds
#
#  Revision 1.76  2007/05/18 19:57:32  sfiligoi
#  Add support for listds of schedds
#
#  Revision 1.75  2007/05/18 19:36:21  sfiligoi
#  Add support for entry-specific schedd_names
#
#  Revision 1.74  2007/05/18 19:07:18  sfiligoi
#  Add CVS tags
#
#
###########################################################
