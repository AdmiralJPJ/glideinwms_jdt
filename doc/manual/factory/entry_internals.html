<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
	<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=utf-8">
	<TITLE>The Factory Entry Daemons</TITLE>
	<META NAME="GENERATOR" CONTENT="OpenOffice.org 2.4  (Linux)">
	<META NAME="CREATED" CONTENT="0;0">
	<META NAME="CHANGEDBY" CONTENT="Igor Sfiligoi">
	<META NAME="CHANGED" CONTENT="20081007;9400100">
	<META NAME="CHANGEDBY" CONTENT="Igor Sfiligoi">
	<META NAME="CHANGEDBY" CONTENT="Igor Sfiligoi">
	<META NAME="CHANGEDBY" CONTENT="Igor Sfiligoi">
	<META NAME="CHANGEDBY" CONTENT="Igor Sfiligoi">
	<META NAME="CHANGEDBY" CONTENT="Igor Sfiligoi">
	<META NAME="CHANGEDBY" CONTENT="Igor Sfiligoi">
	<META NAME="CHANGEDBY" CONTENT="Igor Sfiligoi">
</HEAD>
<BODY LANG="en-US" DIR="LTR">
<H1>The Factory Entry Daemons</H1>
<H2>Description</H2>
<P>This document describes the internals of a glideinWMS Factory
Entry Daemon.</P>
<H2>Index</H2>
<UL>
	<LI><P><A HREF="#overview">Glidein Factory Overview</A></P>
	<LI><P><A HREF="#flow">Program flow</A></P>
	<UL>
		<LI><P><A HREF="#flow_work">Find and perform work</A></P>
		<LI><P><A HREF="#flow_advertise">Advertise myself</A></P>
		<LI><P><A HREF="#flow_stats">Write statistics</A></P>
	</UL>
	<LI><P><A HREF="#source">Source code distribution</A></P>
</UL>
<H2><A NAME="overview"></A>Glidein Factory Overview</H2>
<P>A <a href="index.html">Glidein Factory</a> is composed of a Factory daemon and several
Factory Entry Daemons. Each Entry Daemon is autonomous; it advertises
itself and processes the incoming requests.<BR>See the picture below
for a logical overview.<BR><BR><BR><IMG SRC="entry_points_overview.png"><BR><BR>All
daemons of a Glidein Factory share the same directory tree. The root
of the tree contains the common startup and configuration files,
while each entry point has a few additional configuration files on
its own. Each entry point is completely described by these files on
disk.</P>
<H2><A NAME="flow"></A>Program flow</H2>
<P>The Factory Entry Daemon is based on the polling principle; it
runs in an eternal loop as described in the picture below.</P>
<P><IMG SRC="flow_entry_main.png"><BR>The
configuration is read only once, at daemon startup, so a restart is
needed for every configuration change.<BR>However, the daemon does
check the downtime file at every iteration, so a change to the
downtime configuration file does not need any further action on the
daemon.</P>
<P>Most stages are self explanatory, so they will not be described to
further detail. However a few need more detail; in particular:</P>
<UL>
	<LI><P><A HREF="#flow_work">Find and perform work</A></P>
	<LI><P><A HREF="#flow_advertise">Advertise myself</A></P>
	<LI><P><A HREF="#flow_stats">Write statistics</A></P>
</UL>
<H3><A NAME="flow_work"></A>Find and perform work</H3>
<P>This stage is composed of three logical parts, as shown in the
picture below:</P>
<UL>
	<LI><P>Find the requests by querying the <A HREF="http://www.cs.wisc.edu/condor/manual/v7.0/3_1Introduction.html#SECTION00412000000000000000">Condor
	Collector</A></P>
	<LI><P>For each request:</P>
	<UL>
		<LI><P>Keep the required number of idle jobs in the <A HREF="http://www.cs.wisc.edu/condor/manual/v7.0/3_1Introduction.html#SECTION00412000000000000000">Condor
		Schedd (G)</A> queue</P>
		<LI><P>Extract the statistics</P>
	</UL>
</UL>
<P><IMG SRC="flow_entry_work.png"></P>
<P>This stage requires two input fields, the configuration data and
the downtime flag, and returns the request-specific job statistics.</P>
<P>It also communicates with external Condor daemons. To talk to
them, it currently uses the condor command line tools:</P>
<UL>
	<LI><P><A HREF="http://www.cs.wisc.edu/condor/manual/v7.0/condor_status.html">condor_status</A>
	to query the Condor Collector</P>
	<LI><P><A HREF="http://www.cs.wisc.edu/condor/manual/v7.0/condor_q.html">condor_q</A>
	to query the Condor Schedd</P>
	<LI><P><A HREF="http://www.cs.wisc.edu/condor/manual/v7.0/condor_submit.html">condor_submit</A>
	to submit new jobs to and to release held jobs in the Condor Schedd 
	</P>
</UL>
<P>The requests are inserted into the Condor Collector by the <A HREF="../frontend/index.html">VO
frontends</A>. The picture below shows the format of the request as
present in the Collector.</P>
<P><IMG SRC="../frontend_publish.png"></P>
<H3><A NAME="flow_advertise"></A>Advertise myself</H3>
<P>The advertise stage advertises the existence of the Entry Daemon
and its statistics to the <A HREF="http://www.cs.wisc.edu/condor/manual/v7.0/3_1Introduction.html#SECTION00412000000000000000">Condor
Collector</A>. <BR>Two classes of ClassAds are sent, one for the
Entry Daemon itself, and one for every processed event. The two types
of ClassAds are shown in the pictures below.</P>
<P><IMG SRC="../factory_publish.png"><BR><BR><BR>
</P>
<P><IMG SRC="../factory_client_publish.png"><BR><BR><BR>
</P>
<P>The current implementation uses a Condor provided command line
tool, namely <A HREF="http://www.cs.wisc.edu/condor/manual/v7.0/condor_advertise.html">condor_advertise</A>,
for this task.</P>
<H3><A NAME="flow_stats"></A>Write statistics</H3>
<P>The write statistics stage converts the in-memory statistics into
files in the Web exported monitoring area, as shown in the picture
below. 
</P>
<P><IMG SRC="flow_entry_stats.png"><BR>The
XML status and the <A HREF="http://oss.oetiker.ch/rrdtool/">RRD</A>
updates are done synchronously with the rest of the application. 
</P>
<P>HTML and graph creation is instead done in a separate thread, and
may not be performed in all cycles. If the graphs are not created in
one iteration, there is no data loss, just the graphed information on
the Web is older. This way the daemon can maintain the desired number
of jobs in the queue and keep all the history even when graph
creation exceeds the CPU and IO resources of the machine.</P>
<P>The current implementation will use the Python <A HREF="http://oss.oetiker.ch/rrdtool/">RRDTool
library</A>, if available. Else, it will fall back to the command
line tool.</P>
<H2><A NAME="source"></A>Source code distribution</H2>
<P>The Factory Entry Daemons are implemented as python scripts, and
they don't need to be pre-compiled.</P>
<P>The code is spread over several python modules, some specific to the
factory other shared between different parts of the glideinWMS. 
A shell script is also used.
<BR>There are also some external dependencies, namely the 
<a href="http://oss.oetiker.ch/rrdtool/">rrdtool</a> and 
<a href="http://chandlerproject.org/bin/view/Projects/MeTooCrypto">M2Crypto</a>
python libraries and the 
<a href="http://www.cs.wisc.edu/condor/">Condor</a>
command line binaries.</P>
<P>The picture below shows the dependency tree.</P>
<P><IMG SRC="modules_entry.png"><BR CLEAR=LEFT>glideFactoryEntry.py
is executable.</P>
<P>The glideinWMS common libraries are in glideinWMS/lib directory.<BR>
The shell script is located in the root directory of the factory tree,
copied there during the <a href="index.html#create_entry">creation of the tree itself</a>.
</P>
<P>
</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=2 CELLSPACING=2>
	<TR VALIGN=TOP>
		<TD>
			<H2 ALIGN=LEFT>Repository</H2>
			<H3 ALIGN=LEFT>CVSROOT</H3>
			<P ALIGN=LEFT>cvsuser@cdcvs.fnal.gov:/cvs/cd</P>
			<H2 ALIGN=LEFT>Package(s)</H2>
			<P ALIGN=LEFT>glideinWMS/factory</TD>
		<TD>
			<H2 ALIGN=LEFT>Author(s)</H2>
			<P ALIGN=LEFT>Since Aug. 14th 2006 - Igor Sfiligoi (Fermilab Computing
			Division)</TD>
	</TR>
</TABLE>
<P><BR><BR>
</P>
</BODY>
</HTML>
